<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/" xmlns:activity="http://activitystrea.ms/spec/1.0/" ><channel><title>명월의 개발 일기</title><link>http://www.nowonbun.com</link><description>어두운 밤길을 비추는 달빛처럼.. 어둡고 외로운 개발의 길을 걷는 이들의 밝은 달빛이 되길 바라는 개발자... 프로그램 개발 간의 고민, 문제점을 해결하는 방법 등의 노하우를 일기 형식으로 공유하는 블로그.</description><language>ko</language><pubDate>Thu, 06 Dec 2018 13:19:31 GMT</pubDate><generator>nowonbun blog editor</generator><managingEditor>nowonbun@gmail.com</managingEditor><webMaster>nowonbun@gmail.com</webMaster><item><title>[블로그 구축 18일차] 블로그 댓글 시스템 달기 -9 (client 작성)</title><link>http://www.nowonbun.com/Dialy/90f51b80de17467fb55c535980313ff9.html</link><description> 이번에는 이번 기능추가에 가장 복잡할 거라고 예상되는 검색 부분입니다. 검색해서 받아온 데이터를 동적으로 element를 생성하고 dom 영역에 생성을 해야 하는 로직이 필요하다고 생각되기 때문입니다. 먼저 소스를 전체적으로 작성하고 세부적인 부분을 확인해 보겠습니다.

function getCommentList(){
  var data = "url="+location.origin + location.pathname + "&amp;" +
             "id="+auth.id + "&amp;" +
             "email="+auth.email; 
  commentAjax("/select.php", data, false, function(node){
    $("#commentList").html("");
    var $target = $("#commentList");
    function createComment(idx, email, createdate, lastupdated, comment, ismodify, isreply){
      var div = $("&lt;div&gt;&lt;/div&gt;").addClass("comment-item");
      if(isreply){
        div.addClass("comment-reply");
      }
      div.append($("&lt;input type='hidden'&gt;").addClass("comment-idx").val(idx));
      var header = $("&lt;div&gt;&lt;/div&gt;").addClass("comment-header");
      $area = $("&lt;div class='command-item-panel'&gt;&lt;/div&gt;");
      if(isreply){
        $area.append($("&lt;i class='fa fa-mail-reply'&gt;&lt;/i&gt;"));
      }
      if(email == "admin"){
        email = "주인장";
      }
      $area.append($("&lt;span&gt;&lt;/span&gt;").text("작성자: "+email));
      $area.append($("&lt;span&gt;&lt;/span&gt;").text("작성일: "+createdate));
      $area.append($("&lt;span&gt;&lt;/span&gt;").text("수정일: "+lastupdated));
      header.append($area);
      div.append(header);
      div.append($("&lt;div&gt;&lt;/div&gt;").addClass("comment-box").text(comment));
      $area = $("&lt;div style='text-align:right' class='command-item-panel'&gt;&lt;/div&gt;");
      if(ismodify){
        $area.append($("&lt;span&gt;&lt;a href='javascript:void(0);' class='comment-modify' data-idx='"+idx+"'&gt;수정&lt;/a&gt;&lt;/span&gt;"));
        $area.append($("&lt;span&gt;&lt;a href='javascript:void(0);' class='comment-delete' data-idx='"+idx+"'&gt;삭제&lt;/a&gt;&lt;/span&gt;"));
      }
      if(!isreply &amp;&amp; $.trim(auth.id) !== "" &amp;&amp; $.trim(auth.email) !== ""){
        $area.append($("&lt;span&gt;&lt;a href='javascript:void(0);' class='comment-re' data-idx='"+idx+"'&gt;리플달기&lt;/a&gt;&lt;/span&gt;"));
      }
      div.append($area);
      return div;
    }
    function getItem(list,sub){
      for(var i=0;i &lt; list.length; i++){
        var $node = list[i];
        var el = createComment($node.idx, $node.email, $node.createdate, $node.lastupdated, $node.comment, $node.ismodify, sub);
        $target.append(el);
        if($node.child != null &amp;&amp; $node.child.length &gt; 0){
          getItem($node.child, true);
        }
      }
    }
    getItem(node, false);
  });
}
 검색은 우리가 검색 버튼을 눌러서 발생하는 이벤트가 아니고 처음 웹페이지가 열리고 호출, 추가, 삭제, 수정이벤트가 끝나고 reload 할 때 호출하는 형식입니다. 그러니 따로 document.ready에 넣어 이벤트로 만들 필요는 없습니다. 검색 버튼이 없으니 이벤트로 만들 수가 없네요.. 검색의 필요 파라미터는 url, id, email이었습니다. url은 페이지의 주소, id와 email은 로그인 했을 때의 유저 정보가 됩니다. 로그인하지 않아도 댓글 검색은 이루어져야 하니 id, email에 반드시 유저 정보가 있을 필요는 없습니다. 공통함수 commentAjax를 호출해서 서버에서 데이터를 받아옵니다. 받아오면 아래와 같은 json 형식으로 데이터를 받아오겠네요. 구조는 전체 댓글 두 개, idx가 1인 데이터는 child도 한 개가 있네요. 이 데이터를 최초 getItem라는 내부함수에서 처리합니다. getItem에서는 다시 createComment를 호출해서 element를 작성하고 최종적으로는 id가 commentList라는 element에 append를 합니다. isModify 파라미터가 true인 경우는 수정할 수 있습니다. 서버에서 isModify가 true의 조건은 id, email이 일치하는 경우였습니다. 즉, 내가 쓴 댓글을 수정삭제가 가능하다는 뜻이네요. 설명은 워낙 간단합니다만 실제 이걸 작성할 때는 꽤 많은 시간을 투자했습니다. 소스 흐름 자체는 간단한데 디자인을 맞추다 보니 힘들어졌네요. 여기서 저는 새로 생성하는 element를 자바스크립트 안에 코딩했습니다. 이 방식에 대해서는 여러 방법이 있습니다. 웹 dom영역에서 template 태그 안에 element를 넣고 읽어드려 치환하는 방법이 있고 저처럼 자바스크립트 안에 넣는 방법이 있습니다. 일단 코딩하는 데는 template 태그 안에 넣는 방법이 편합니다. 그러나 template 태그 안에 넣으면 element가 전부 노출이 되기 때문에 그걸로 악용하는 사람도 더러 있더라고요.. 뭐 코딩하는 방법에 따라 다릅니다만.. 저는 그래서 자바스크립트 안에 element를 작성하는 방법을 선호합니다. 최종 배포할 때 자바스크립트는 전부 압축을 해버리기 때문에 그러면 보안상으로 조금 안전해집니다. 그러나 시스템 망가트리려고 마음먹으면 압축을 해도 소용없습니다.ㅠㅠ
$(document).on("click", ".comment-delete", function(){
  if(!checkLogin()) return;
  var $this = $(this);
  var data = "url="+location.origin + location.pathname + "&amp;" +
         "idx="+$this.data("idx") + "&amp;" +
         "id="+auth.id + "&amp;" +
         "email="+auth.email;
  commentAjax("/delete.php", data, true, function(){
    toastr.success("삭제되었습니다.");
  });
});
 삭제의 경우는 댓글 검색이 끝나고 위 이미지처럼 삭제 링크를 누르면 발생하는 이벤트입니다. 저 링크의 경우는 동적으로 생성되는 element이기에 이벤트를 document에 걸었습니다. document는 사라지거나 하지 않기 때문에. 그러면 삭제 element가 없어졌다 다시 생기더라도 이벤트는 걸립니다. document에 이벤트를 걸때는 주의를 해야 할 점이 우리 댓글 기능은 워낙 작아서 가능성이 작지만 큰 프로젝트라면 이벤트를 중복으로 걸수 있는 위험이 있습니다. 예를 들면 내용이 비슷한 페이지를 particle로 구성하고 안에 같은 document 이벤트가 있다고 가정할 시 두 번 중첩 이벤트가 걸립니다. 두 번 중첩은 이벤트가 두 번 발생할 수 있는 의미입니다. 그러면 버그가 발생하기 때문에 off.on 형태로도 많이 구성하나 결론적으로 off.on 형식으로 코딩을 하면 그만큼 리소스를 많이 먹고 시스템이 느려집니다. 그렇기 때문에 이벤트 target을 정할 때는 이건 동적 소스, 정적소스를 확실히 구분해서 이벤트를 거는 게 좋습니다. 이것도 기회가 되면 언제고 다시 설명할게요. 삭제는 서버에서 요구하는 파라미터가 idx, url, id, email입니다. idx는 삭제할 타깃이고 url은 정합성, id, email은 권한 체크용을 받습니다. 이 조건이 맞으면 삭제가 진행됩니다. 다음은 수정과 리플등록 부분만 작성하면 전체적인 댓글 기능은 완성이 되네요. 댓글 기능의 소스는 제 github에 등록되어있습니다. 혹시 사용하실 분들은 fork해서 가져가서 편히 쓰시면 됩니다.github - https://github.com/nowonbun/BlogComment</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/90f51b80de17467fb55c535980313ff9.html</guid><pubDate>Thu, 06 Dec 2018 21:53:31 GMT</pubDate></item><item><title>[블로그 구축 17일차] 블로그 댓글 시스템 달기 -8 (client 작성)</title><link>http://www.nowonbun.com/Dialy/c4097e40237147c696ba6c0af47a8718.html</link><description> 앞 포스트에서는 기본 디자인과 로그인에 대해서 작성했습니다. 이번에는 공통부분과 댓글 추가하는 부분을 만들어 볼까 합니다.검색 부분은 조금 복잡하기 때문에 다음 포스트에서 한꺼번에 하는 게 구분상 좋을 거 같네요. 웹서비스에서 담당하는 웹 스크립트는 javascript입니다. 그러나 javascript의 바닐라 버전(순수 버전)으로 사용하면 꽤 복잡해져요. 사실 한 10년 전만 해도 바닐라 버전만 사용했었는데 최근에는 jquery만 사용하다 보니 다시 바닐라 버전으로만 개발하라고 하면 생각만으로 끔찍합니다. 코드가 어마어마하게 길어질 거예요.. 그래서 요즘은 angularJs, jquery 등 많은 라이브러리가 있는데, 저는 jquery만 사용합니다. 예전에 angularJs로 만들어 본 적은 있는데 이게 편하다고 하는데 저는 당최 뭐가 편한지 모르겠더라고요. 코드만 더 길어지고 복잡만 해지는 것 같던데.. 물론 onepage 시스템을 만들면 편할 거 같다고는 생각하는데 굳이 onepage로 시스템을 통으로 만들 필요성을 못 느끼기에... jquery는 javascript의 라이브러리입니다. 이 뜻은 jquery라 javascript의 기반으로 함수를 좀 더 편하게 사용하기 위해 재정의를 했다고 보면 됩니다. 그 뜻은 jquery를 사용하더라도 javascript를 모르면 사용할 수 없다는 뜻입니다. 이하 부터 javascript라고 표현하는 것은 jquery 라이브러리 기반이라고 생각하면 됩니다.
function commentAjax(url,data,reload,cb){
  $.ajax({
    url: "//*댓글 서버 URL*//"+url,
    type: "POST",
    dataType: "json",
    data: data,
    success: function (data, textStatus, jqXHR) {
      cb.call(this, data);
      if(reload){
        // 검색
      }
    },
    error: function (jqXHR, textStatus, errorThrown) {
      console.log(jqXHR);
      $("#commentSystem").css("text-align","center");
      $("#commentSystem").html("&lt;img src='/img/image_fix.png' style='height: 40px'&gt;");
      toastr.success("시스템 에러입니다.");
    },
    complete: function (jqXHR, textStatus) { }
  });
}
function checkLogin(){
  if($.trim(auth.id) === ""){
    toastr.error("로그인 해주시기 바랍니다.");
    return false;
  }
  if($.trim(auth.email) === ""){
    toastr.error("로그인 해주시기 바랍니다.");
    return false;
  }
  return true;
}
 원래 저는 javascript 코드를 만들 때, model-controller로 구성하고 외부 참조변수, 내부 변수 구분해서 구조를 짭니다. 그러나 지금 만드는 기능은 워낙 사이즈가 작고 간단한 프로그램이라 오히려 model-controller로 만들어서 하면 더 복잡해질 거 같아서, 그냥 public function으로 만들었습니다. 다음에 기회가 있으면 제대로 만들어서 포스팅하겠습니다. 먼저 commentAjax는 추가, 검색, 삭제, 수정이 모두 ajax로 서버로 접속하기 때문에 공통으로 묶었습니다. 서버 모두 post 형식으로 받기 때문에 타입은 POST로 고정하고, 모두 json형식으로 데이터를 받기때문에 데이터 타입도 json으로 고정했습니다. 그리고 성공했을 때는 cb의 콜백함수를 호출하고 댓글을 다시 reload하는 형식으로 구성했습니다. 에러가 나면 에러 메시지가 나오고 댓글 element를 잠급니다. checkLogin은 우리가 서버로 접속하기 전에 무조건 login상태를 확인하기 위한 공통함수입니다.여기까지는 워낙 간단해서 추가로 설명할 것도 없을 거 같네요.
$(function(){
  $("#createComment").on("click", function(){
    if(!checkLogin()) return;
    var comment = $("#commentText").val().replace("\r\n"," ").replace("\r"," ").replace("\n"," ");
    if($.trim(comment) === ""){
      toastr.error("댓글 내용을 입력해 주시기 바랍니다.");
      return;
    }
    var data = "url="+location.origin + location.pathname + "&amp;" +
               "id="+auth.id + "&amp;" +
               "email="+auth.email + "&amp;" +
               "comment="+comment;
    commentAjax("/add.php", data, true, function(){
      toastr.success("등록되었습니다.");
      $("#commentText").val("");
      $(".comment-textarea-label").removeClass("active");
    });
  });
});
 댓글을 추가하는 부분입니다. 기본적으로 저는 javascript를 html 구성 중 가장 밑에 배치하므로 document.ready를 기다릴 필요는 없습니다. 그러나 코드의 가독성과 앞으로 어떻게 수정될지 모르기 때문에 이벤트를 document.ready안에 넣습니다. document.ready는 jquery에서 $(function(){ }); 의 형태로 작성합니다.댓글 추가할 때는 최초 공통함수의 로그인 체크합니다. 그리고 comment영역에서 엔터를 모두 띄어쓰기로 치환했습니다. 300자 제한을 했는데 모두 엔터를 쳐서 입력하면 댓글 구조가 이상해 질꺼봐입니다. 이 부분을 서버 부분에서도 체크하는 게 좋을 것 같네요.. 만들다 보니 그런 생각이 듭니다. 수정해놔야겠습니다. 그리고 파라미터는 서버 요구사항대로 url, id, email, comment를 받아서 전송하면 되겠네요. id, email은 구글 oauth2에서 받은 정보입니다. 그리고 성공 콜백이 오면 등록 메시지 표시하고 코멘트 텍스트 박스를 초기화합니다. 댓글 추가는 간단해서 어려운 코드가 없네요. 다음은 가장 복잡할 거라 생각되는 검색부분입니다.댓글 기능의 소스는 제 github에 등록되어있습니다. 혹시 사용하실 분들은 fork해서 가져가서 편히 쓰시면 됩니다.github - https://github.com/nowonbun/BlogComment</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/c4097e40237147c696ba6c0af47a8718.html</guid><pubDate>Wed, 05 Dec 2018 22:28:41 GMT</pubDate></item><item><title>[블로그 구축 16일차] 블로그 댓글 시스템 달기 -7(server 작성)</title><link>http://www.nowonbun.com/Dialy/commentDisign.html</link><description> 벌써 블로그 구축 프로젝트를 시작한 지 보름이 지났습니다. 그러나 아직　생각처럼 진척이 팍팍 나가지 않네요. 조금 답답합니다. 그래도 올해 말에 꼭 하고 싶은 프로젝트가 있기 때문에 최대한 30일 차 이전에 끝내는게 목표입니다. 댓글 기능의 서버 쪽 구현은 약 70% 정도 완료가 되었습니다. 아직 테스트도 제대로 되지 않아서 버그가 있을 거 같긴 하지만, 주요 부분은 일단 구현이 되었습니다. client까지 빨리 만들고 서버 쪽 관리 페이지와 메일 기능을 추가해서 빨리 완성해야 겠습니다. 블로그를 한 2~3주간 사용해보니 이곳저곳에서 버그도 조금씩 보이고 할 게 많네요.. 아직 방문자가 없어서 다행입니다. ㅎㅎ 이게 진짜 다행인지... 이번에는 client쪽을 구현해 볼까 합니다. client 쪽이라고 하면 브라우저, 즉 제 블로그에서 javascript(jquery)를 통해 서버로 접속해서 댓글 추가, 검색, 수정, 삭제 부분을 말합니다. 서버 쪽은 화면 디자인은 필요 없지만 client 영역은 화면 디자인이 필요하니 우선 디자인을 먼저 해야겠네요.
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;
  &lt;meta name="google-signin-client_id" content=""&gt; &lt;!-- 구글 인증 client_id 넣는 란 --&gt;
 
  &lt;title&gt;&lt;/title&gt;
  &lt;link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous"&gt;
  &lt;link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous"&gt;
  &lt;link href="http://www.nowonbun.com/css/compiled-4.5.9.min.css" rel="stylesheet"&gt;
  &lt;link href="http://www.nowonbun.com/css/style.min.css" rel="stylesheet"&gt;
  &lt;link href="http://www.nowonbun.com/css/common.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body lang="ko" aria-busy="true"&gt;
  &lt;div id="bodyMain" class="container wow fadeIn animated" style="visibility: visible; animation-name: fadeIn;"&gt;
    &lt;main class="mt-5"&gt;
      &lt;fieldset class="box-shadow-0 px-3 py-3 blog-radius mb-3 my-style-custom"&gt;
        &lt;legend class="box-shadow-0 blog-legend px-3 blog-radius"&gt;
          &lt;label&gt;댓글 달기&lt;/label&gt;
        &lt;/legend&gt;
        &lt;div id="commentSystem"&gt;
          &lt;div id="googleSigninButton"&gt;&lt;/div&gt; &lt;!-- g-signin2 DIV 컬럼 --&gt;
          &lt;div id="commentInsertForm" class="comment-form-border"&gt;
            &lt;div style="text-align:right;"&gt;
              &lt;button type="button" class="btn btn-sm btn-outline-success waves-effect" id="createComment"&gt;작성하기&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="md-form comment-form"&gt;
              &lt;textarea id="commentText" class="form-control md-textarea comment-textarea" maxlength="300" length="300" rows="3"&gt;&lt;/textarea&gt;
              &lt;label for="commentText" class="comment-textarea-label"&gt;댓글 작성하기&lt;/label&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div id="commentList" class="comment-list"&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/fieldset&gt;
    &lt;/main&gt;
  &lt;/div&gt;
  &lt;script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="http://www.nowonbun.com/js/compiled-4.5.9.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"&gt;&lt;/script&gt;
  &lt;script src="https://apis.google.com/js/platform.js?onload=onLoad" async defer&gt;&lt;/script&gt;
  &lt;script&gt;
  var auth = {
    id: null,
    email: null
  };
  function onSignIn(googleUser) {
    $("#commentInsertForm").show(); // 댓글 작성 폼 뷰
    $("#googleSigninButton").hide(); // 구글 로그인 뷰
 
    var profile = googleUser.getBasicProfile(); // 구글 oAuth2 정보 취득
    auth.id = profile.getId();
    auth.email = profile.getEmail();
    getCommentList();
    //console.log(profile);
    //__proto__
 
    //var id_token = googleUser.getAuthResponse().id_token;
    //console.log("ID Token: " + id_token);
  }
  function onFailure(error){
    console.log(error);
  }
  function onLoad() {
    gapi.load('auth2,signin2', function() {
      var auth2 = gapi.auth2.init();
      auth2.then(function() {
        // Current values
        var isSignedIn = auth2.isSignedIn.get();
        var currentUser = auth2.currentUser.get();
 
        gapi.signin2.render('googleSigninButton', {
          'onsuccess': 'onSignIn',
          'onfailure': 'onFailure',
          'longtitle': true,
          'theme': 'dark',
          'width': '0'
        });
        /*auth2.signOut().then(function () {
        debugger;
        $('.userContent').html('');
        $('#gSignIn').slideDown('slow');
        }); */
        //console.log(currentUser);
        if (!isSignedIn) {
          $("#commentInsertForm").hide();
          $("#googleSigninButton").show();
          getCommentList();
        } else {
          $("#commentInsertForm").show();
          $("#googleSigninButton").hide();
        }
      });
    });
  }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

 이 댓글 기능은 우선, 제 블로그에서 사용할 것이기 때문에 최대한 css와 js를 블로그와 일치시켜서 비슷한 환경으로 구성했습니다. 그리고 그 외의 포스트 내용과 최신글 내용은 현재 필요가 없기 때문에 다 삭제하고 댓글 영역만 복사해서 기본 개발 환경을 설정했습니다. 개발 환경은 가능하면 실제 사용하는 곳과 최대한 비슷하게 구성을 해야 나중에 릴리즈할 때 어려움이 없습니다. client의 개발 구성은 먼저 로그인, 예전에 조사했던 google oauth2로 로그인 화면을 만들고, 그다음에는 입력, 검색, 삭제, 수정순으로 기능을 추가할까 생각하고 있습니다.로그인 기능은 google의 가이드를 보고 참고했습니다.https://developers.google.com/identity/sign-in/web/ 가이드에서는 로그인박스를 넣은 div를 선언하고 meta태그에 google client id를 넣고 구글에서 제공하는 js를 링크하고 onSignIn함수를 넣으라고 설명이 되어있네요. 그대로 쓰기에는 제 사양과 다르기 때문에 조금 수정했습니다.https://stackoverflow.com/questions/31331428/how-to-call-getbasicprofile-of-google-to-google-signin-on-only-button-click 예전에 조사한 스택 오버플로우에 올린 글입니다만 여기에는 div영역의 id를 바꿀 수 있고 이벤트 명도 수정할 수 있네요. 저는 아래의 링크를 참고하여 위의 소스처럼 작성했습니다. 구글의 oAuth의 경우는 로그아웃이 되어있으면 자동으로 구글 로그인 버튼이 나옵니다. 로그인이 되어있지 않으면 자동으로 로그인 버튼이 hide됩니다. 저는 로그인이 되어있으면 댓글을 입력할 수 있는 text-box와 입력 버튼이 보이게끔 작성했습니다. 뭐 여기까지 일반적인 로그인 방법과 댓글 작성하는 디자인입니다. 딱히 여기에 대해서 제가 더 글을 쓸 내용이 없네요..ㅠㅠ 하고자 한다면 우리가 UI를 구성할 때면 자신만의 특별한 기능, 특별한 디자인으로 구성하는 사람도 있지만 저는 가장 보편적인 디자인과 기능을 선호하는 편입니다. 왜냐하면 프로그램을 설계하다 보면 유저의 사용자 학습 부분도 검토해야 합니다. 만약에 지금은 단순히 댓글 기능이라 생각할 것도 별로 없지만 간단하게 생각하면 윈도우 메뉴바는 하단, 시작 버튼은 왼쪽 아래, 맥은 상단에 있네요.. 이렇게 있는데 나는 독특한 기능이라고 마우스 왼쪽 오른쪽 동시에 누르면 메뉴가 나오게끔 설계를 하면 사람들이 아마 메뉴가 어디 갔지? 메뉴를 찾는 데 시간을 많이 소비할 것입니다. 그리고 방법을 알고 있더라도 아직 사람들이 익숙하지 않기 때문에 많이 헤멜수도 있고요. 그럼 아무리 좋은 기능, 혁신적인 기능이라도 사용자 학습이 되지 않은 기능들은 그냥 불편한 기능일 뿐입니다.그런 면에서 보면 스티브 잡스가 대단한 것입니다. 새로운 시스템, 기능이 나와도 사람들이 많은 어려움 없이 쉽게 흡수가 되는 그런 설계를 하는 것. 이건 쉽지만 매우 어려운 일입니다. 여기까지 이야기 하다 보니 사용자 학습에 대한 것도 참 할말이 많네요. 다음에 기회 있으면 포스팅을 해야겠습니다. 댓글 기능의 소스는 제 github에 등록되어있습니다. 혹시 사용하실 분들은 fork해서 가져가서 편히 쓰시면 됩니다.github - https://github.com/nowonbun/BlogComment</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/commentDisign.html</guid><pubDate>Tue, 04 Dec 2018 23:13:59 GMT</pubDate></item><item><title>[블로그 구축 15일차] 블로그 댓글 기능 달기 -6(server 작성)</title><link>http://www.nowonbun.com/Dialy/comment_delete_modify20181204.html</link><description> 사람마다 설계하는 구조와 방식, 진행 방법이 다 다릅니다. 보통 자기만의 경험으로 가장 최적의 방식이 있습니다. 그래서 제가 작성하는 방식은 반드시 최적은 아닙니다. 저는 프로젝트마다 다르지만 보통 입력영역을 우선으로 만들고 그다음은 검색, 삭제, 마지막으로 수정하는 영역 순으로 개발을 합니다. 저한테는 이런 순서가 가장 중복작업을 피하고 소스가 가장 깔끔하게 만들어지지 않나 싶네요. 그래서 앞 포스트에서 입력과 검색영역을 만들었으니 이번에는 삭제와 수정기능을 만들어 볼까 생각하고 있습니다.
	&lt;?php
include_once $_SERVER ['DOCUMENT_ROOT'] . '/common.php';
class Controller extends AbstractDao{
  protected function run(){
    if(strtoupper ( $_SERVER ['REQUEST_METHOD'] ) == 'POST'){
      $url = $_REQUEST["url"];
      $idx = (int)trim($_REQUEST["idx"]);
      $id = $_REQUEST["id"];
      $email = $_REQUEST["email"];
      parent::validateUrl($url);
      parent::validateIdx($idx);
      parent::validate($id);
      parent::validate($email);
      
      $stmt = null;
      if(parent::isSuperUser($id, $email)){
        $stmt = parent::getStmt ( "UPDATE COMMENT_T SET ISDELETED=1, LASTUPDATED=now() WHERE IDX=? AND URL=?" );
        $stmt-&gt;bind_param ( "is", $idx, $url);
      } else {
        $stmt = parent::getStmt ( "UPDATE COMMENT_T SET ISDELETED=1, LASTUPDATED=now() WHERE IDX=? AND URL=? AND ID=? AND EMAIL=?" );
        $stmt-&gt;bind_param ( "isss", $idx, $url, $id, $email);
      }
      if ($stmt-&gt;execute ()) {
        parent::close();
        return array ("result" =&gt; "OK");
      } else {
        parent::close();
        return array ("result" =&gt; "NG");
      }
    } else {
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
}
$obj = new Controller();
?&gt;
&lt;?=$obj-&gt;execute()?&gt;

 삭제에는 많은 파라미터가 필요 없습니다. 먼저 키가 되는 idx와 그걸 삭제할 수 있는 권한체크만 가능하면 삭제가 되겠네요. idx만으로 삭제를 해버리면 누구든 데이터를 삭제할 수 있기 때문이죠. 그래서 파라미터에서 idx는 당연히 받고 url, id, email이 일치하면 그 데이터를 삭제할 수 있게 했습니다. 추가로 id가 super 유저라고 하면 id, email은 일치하지 않아도 삭제할 수 있게 만들었습니다. 전체적인 흐름은 추가 소스와 비슷합니다. GET방식이면 401에러를 리턴하고 등등. 완료되면 json으로 OK값을 리턴합니다.
&lt;?php
include_once $_SERVER ['DOCUMENT_ROOT'] . '/common.php';
class Controller extends AbstractDao{
  protected function run(){
    if(strtoupper ( $_SERVER ['REQUEST_METHOD'] ) == 'POST'){
      $url = $_REQUEST["url"];
      $idx = (int)trim($_REQUEST["idx"]);
      $ip = $_SERVER["REMOTE_ADDR"];
      $id = $_REQUEST["id"];
      $email = $_REQUEST["email"];
      $comment = $_REQUEST["comment"];
      parent::validateUrl($url);
      parent::validateIdx($idx);
      parent::validate($ip);
      parent::validate($id);
      parent::validate($email);
      parent::validate($comment);
      $stmt = null;
      if(parent::isSuperUser($id, $email)){
        $stmt = parent::getStmt ( "INSERT INTO COMMENT_H (oIDX,URL,ID,IP,EMAIL,COMMENT,PARENT,ISDELETED,CREATEDDATE,LASTUPDATED,HISTORYDATE) 
                                   SELECT IDX,URL,ID,IP,EMAIL,COMMENT,PARENT,ISDELETED,CREATEDDATE,LASTUPDATED,now() FROM COMMENT_T 
                                   WHERE IDX=? AND URL=? AND ISDELETED=0" );
        $stmt-&gt;bind_param ( "is", $idx, $url);
      } else {
        $stmt = parent::getStmt ( "INSERT INTO COMMENT_H (oIDX,URL,ID,IP,EMAIL,COMMENT,PARENT,ISDELETED,CREATEDDATE,LASTUPDATED,HISTORYDATE) 
                                   SELECT IDX,URL,ID,IP,EMAIL,COMMENT,PARENT,ISDELETED,CREATEDDATE,LASTUPDATED,now() FROM COMMENT_T 
                                   WHERE IDX=? AND URL=? AND ID=? AND EMAIL=? AND ISDELETED=0" );
        $stmt-&gt;bind_param ( "isss", $idx, $url, $id, $email);
      }
      if ($stmt-&gt;execute ()) {
        parent::close();
      } else {
        parent::close();
        return "NG";
      }
      $stmt = null;
      if(parent::isSuperUser($id, $email)){
        $stmt = parent::getStmt ( "UPDATE COMMENT_T SET COMMENT=?, IP=?, LASTUPDATED=now() WHERE IDX=? AND URL=? AND ISDELETED=0" );
        $stmt-&gt;bind_param ( "ssis", base64_encode ($comment), $ip, $idx, $url);
      } else {
        $stmt = parent::getStmt ( "UPDATE COMMENT_T SET COMMENT=?, IP=?, LASTUPDATED=now() WHERE IDX=? AND URL=? AND ID=? AND EMAIL=? AND ISDELETED=0" );
        $stmt-&gt;bind_param ( "ssisss", base64_encode ($comment), $ip, $idx, $url, $id, $email);
      }
      if ($stmt-&gt;execute ()) {
        parent::close();
        return array ("result" =&gt; "OK");
      } else {
        parent::close();
        return array ("result" =&gt; "NG");
      }
    } else {
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
}
$obj = new Controller();
?&gt;
&lt;?=$obj-&gt;execute()?&gt;

제가 수정 영역을 가장 마지막에 두는 이유는 두 가지 때문입니다. 입력과 삭제보다 수정은 조금 더 복잡합니다. 그리고 수정은 입력과 삭제의 소스와 비슷하기 때문에 미리 입력과 삭제를 만들면 수정이 좀 더 수월하게 작성할 수 있습니다. 먼저 파라미터는 입력에서 받았던 파라미터와 비슷한데 수정할 idx 키를 하나 더 받습니다. 그리고 수정 권한을 체크하는데 이 부분은 삭제와 비슷하게 url, id, email이 일치하면 수정할 수 있고 일치하지 않으면 수정할 수 없습니다. 그러나 super 유저의 경우는 일치하지 않아도 수정할 수 있습니다. 여기서 저는 입력, 삭제와 다르게 comment_h 테이블(히스토리 테이블)에 insert select를 합니다. 이는 수정의 로그를 남기기 위한 건데, 보통은 이 부분을 소스 상에서 처리하지 않고 트리거로 처리를 많이 합니다. 그러나 현재 제가 사용하고 있는 서버 호스트는 무료 호스트이고 mysql버전이 꽤 옛날 거입니다. 꽤 옛날 거라도 해도 triger는 작동하겠지만, 혹시나 해서 triger 처리하지 않고 직접 소스에서 insert select로 작성했습니다. 덕분에 소스가 조금 지저분해졌네요. 만약 이게 복잡한 프로젝트였다면 이렇게 하면 프로그램 참 어렵게 한다고 하겠지만 간단한 프로그램이니 이렇게 처리했습니다. 여기까지 서버 영역 프로그래밍이 완료되었습니다. 아직 제가 생각하기에는 admin과 댓글이 달리면 메일 발송영역이던 가가 더 필요할 듯싶은데 우선 댓글 기능을 활성화하는 게 목표이기 때문에 일단 일차 릴리즈가 완료가 되면 추가사항으로 개발할 생각입니다. 위 흐름표는 지금 제가 생각하고 있는 댓글 기능에 대한 설계도(?)입니다.댓글 기능의 소스는 제 github에 등록되어있습니다. 혹시 사용하실 분들은 fork해서 가져가서 편히 쓰시면 됩니다.github - https://github.com/nowonbun/BlogComment</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/comment_delete_modify20181204.html</guid><pubDate>Tue, 04 Dec 2018 01:47:01 GMT</pubDate></item><item><title>[블로그 구축 14일차] 블로그 댓글 기능 달기 -5(server 작성)</title><link>http://www.nowonbun.com/Dialy/22c4b209f70d4f4b95b2bc822da6fc69.html</link><description> 저는 상위 common 추상 클래스와 database connection을 만들었습니다. 블로그 포스트는 너무 길면 보시는 분들이 지루하게 생각할 수 있어서 몇 개로 나눌 생각입니다. 댓글 기능은 이미 완료가 되어서 혹시 사용하고 싶으신 분들은 github에서 fork해서 가져가서 쓰셔도 됩니다. 아직 readme를 작성하지 않아서 github에서 소스만 봐서는 사용하기 어렵겠네요.github - https://github.com/nowonbun/BlogComment
&lt;?php
include_once $_SERVER ['DOCUMENT_ROOT'] . '/common.php';
class Controller extends AbstractDao{
  protected function run(){
    if(strtoupper ( $_SERVER ['REQUEST_METHOD'] ) == 'POST'){
      $url = $_REQUEST["url"];
      $ip = $_SERVER["REMOTE_ADDR"];
      $id = $_REQUEST["id"];
      $email = $_REQUEST["email"];
      $comment = $_REQUEST["comment"];
      $parent = (int)$_REQUEST["parent"];
      if($parent &lt; 1){
        $parent = null;
      }
      parent::validateUrl($url);
      parent::validate($ip);
      parent::validate($id);
      parent::validate($email);
      parent::validate($comment);
      $stmt = parent::getStmt ( "INSERT INTO COMMENT_T (URL, IP ,ID, EMAIL, COMMENT, PARENT, CREATEDDATE, LASTUPDATED) VALUES (?, ?, ?, ?, ?, ?, now(), now())" );
      $stmt-&gt;bind_param ( "sssssi", $url, $ip, $id, $email, base64_encode  ($comment), $parent);
      if ($stmt-&gt;execute ()) {
        parent::close();
        return array ("result" =&gt; "OK");
      } else {
        parent::close();
        return array ("result" =&gt; "NG");
      }
    } else {
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
}
$obj = new Controller();
?&gt;
&lt;?=$obj-&gt;execute()?&gt;
 먼저 common.php에서 만들었던 클래스를 상속받아서 만들었습니다. 소스의 흐름은 POST형식으로만 사용이 가능합니다. GET방식으로 오면 401에러를 발생시킵니다. 그리고 파라미터를 변수로 변환하고 데이터 검사를 한 후에 데이터 베이스에 Insert합니다. Insert 잘 되면 Json 형식의 result키로 OK값을 리턴하고 그렇지 않으면 NG를 리턴합니다. 먼저 어제 페이지를 돌아가면 제가 validateUrl 함수와 validate의 함수를 만들지 않았습니다. add 클래스를 만들면서 이 영역은 추가 부분뿐 아니라 수정, 삭제, 검색에서도 공통으로 사용할 거 같아서 상위 클래스에 만들었습니다. 그럼 다른 클래스에도 동일한 함수를 만들지 않아도 공통으로 쓸 수 있겠네요.. 저는 Copy-phase를 매우 극혐하는 개발자중에 하나입니다.ㅎㅎ 댓글 추가하는 부분은 데이터를 Insert하는 부분이라 어렵지 않습니다.
	&lt;?php
include_once $_SERVER ['DOCUMENT_ROOT'] . '/common.php';
class Controller extends AbstractDao{
  protected function run(){
    if(strtoupper ( $_SERVER ['REQUEST_METHOD'] ) == 'POST'){
      $url = $_REQUEST["url"];
      $pid = $_REQUEST["id"];
      $pEmail = $_REQUEST["email"];
      parent::validateUrl($url);
      $stmt = parent::getStmt ( "SELECT IDX, ID, EMAIL, PARENT, CREATEDDATE, LASTUPDATED, COMMENT from COMMENT_T WHERE URL=? AND ISDELETED=0 ORDER BY IDX DESC" );
      $stmt -&gt; bind_param ( "s", $url );
      $stmt-&gt;execute ();
      $stmt-&gt;bind_result ( $idx, $id, $email, $parent, $createdate ,$lastupdated, $comment );
      $rslt = array ();
      while ( $stmt-&gt;fetch () ) {
        $clz = new Comment ();
        $clz-&gt;setIdx ( $idx );
        $clz-&gt;setId ( $id );
        $clz-&gt;setEmail ( $email );
        $clz-&gt;setParent ( $parent );
        $clz-&gt;setCreatedate ( $createdate );
        $clz-&gt;setLastupdated ( $lastupdated );
        $clz-&gt;setComment ( base64_decode  ($comment) );
        array_push ( $rslt, $clz );
      }
      parent::close();
      
      $ret = array ();
      for($i=0;$i&lt;count($rslt);$i++){
        if($rslt[$i]-&gt;getParent() == null){
          $rslt[$i]-&gt;setChild($this-&gt;getChild($rslt, $rslt[$i]-&gt;getIdx(),$pid, $pEmail));
          array_push ( $ret, $this-&gt;createJsonArray($rslt[$i],$pid, $pEmail) );
        }
      }
      return $ret;
    } else {
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
  
  private function getChild($list, $idx, $pid, $pEmail){
    $ret = array();
    for($i=count($list)-1;$i&gt;=0;$i--){
      if($idx == $list[$i]-&gt;getParent()){
        $list[$i]-&gt;setChild($this-&gt;getChild($list, $list[$i]-&gt;getIdx(),$pid, $pEmail));
        array_push ( $ret, $this-&gt;createJsonArray($list[$i],$pid, $pEmail) );
      }
    }
    return $ret;
  }
  
  private function createJsonArray($node, $id, $email){
    $pos = strpos($node-&gt;getEmail(),"@");
    if($pos &gt; 1){
      $emailb = substr($node-&gt;getEmail(),0, $pos);
    } else {
      $emailb = $node-&gt;getEmail();
    }
    $emailb = substr($emailb,0,3)."******";
    return array (
      "idx" =&gt; $node-&gt;getIdx(),
      "email" =&gt; parent::isSuperUser($node-&gt;getId(), $node-&gt;getEmail())?"admin":$emailb,
      "parent" =&gt; $node-&gt;getParent(),
      "createdate" =&gt; $node-&gt;getCreatedate(),
      "lastupdated" =&gt; $node-&gt;getLastupdated(),
      "comment" =&gt; $node-&gt;getComment(),
      "ismodify" =&gt; trim($node-&gt;getId()) == trim($id) &amp;&amp; trim($node-&gt;getEmail()) == trim($email) || parent::isSuperUser($id, $email),
      "child" =&gt; $node-&gt;getChild() != null? $node-&gt;getChild():null
    );
  }
}
$obj = new Controller();
?&gt;
&lt;?=$obj-&gt;execute()?&gt;


	abstract class AbstractDao {
  private $db;
  private $mysqli;
  
  private $sui = "";
  private $sue = "";
  private $host = "";
  
  protected function getStmt($qy) {
    $this-&gt;db = new DBConn ();
    $this-&gt;mysqli = $this-&gt;db-&gt;get ();
    $stmt = $this-&gt;mysqli-&gt;prepare ( $qy );
    return $stmt;
  }
  protected function close() {
    $this-&gt;mysqli-&gt;close ();
  }
  public function validateIdx($val){
    if($val == null){
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
    if($val &lt; 1){
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
  public function validateUrl($val){
    if($val == null || trim($val) == ""){
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
    if(preg_match("/".$this-&gt;host."/i", $val) == 0){
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
  public function validate($val){
    if($val == null || trim($val) == ""){
      header ( "HTTP/1.1 401 Unauthorized"  );
      http_response_code ( 401 );
      die ();
    }
  }
  public function execute(){
    header("content-type: application/json; charset=utf-8");
    //header("Access-Control-Allow-Origin:*");
    header("Access-Control-Allow-Origin:http://".$this-&gt;host);
    return json_encode($this-&gt;run());
  }
  protected abstract function run();
  protected function getSuperId(){
    return $this-&gt;sui;
  }
  protected function getSuperEmail(){
    return $this-&gt;sue;
  }
  protected function getHost(){
    return $this-&gt;host;
  }
  protected function isSuperUser($id, $email){
    return trim($this-&gt;sui) == trim($id) &amp;&amp; trim($this-&gt;sue) == trim($email);
  }
}

 제 블로그는 프로그램 강좌가 아닙니다만 또 소스가 글의 반이상을 차지하네요.. 그래도 무언가를 쓰려면 소스가 필요하니 어쩔수 없네요..ㅠㅠ 데이터를 Insert했으면 이번에는 검색을 해야 합니다. 구조는 추가 부분과 비슷합니다. POST형식으로 받고 파라미터 검사하고 디비에서 SELECT하는 것입니다. 여기는 공통에서 comment 클래스를 이용합니다. select해서 나온 데이터를 new Comment해서 list에 push합니다. 이렇게 되면 결괏값이 10개 데이터를 검색했다고 하면 10개의 comment 클래스가 list에 할당되는 형태입니다. 이렇게 되면 데이터 베이스 구조와 클래스 구조를 비슷하게 생각할 수 있습니다. sort를 할 수도 있고 필요 없는 데이터는 뺄수도 있고. 검색의 기준은 url로 검색해서 해당 페이지의 댓글만 검색하는 형태입니다.. 그리고 select의 리턴형태는 class형태에서 array 형식으로 변환해서 각 댓글의 리플들을 달았습니다. php는 class형태가 json으로 변환이 되지 않아서 저런 수고로움이 들어가네요. 어떻게 보면 이게 정말 가시적인 형태라 이해하기는 편한데 소스가 길어지니 귀찮네요.. common 클래스도 수정했습니다. add에서 이야기한 것처럼 validate함수, 검사함수를 공통으로 만들었습니다. 단순히 null체크와 url이면 host 주소 검사, Idx면 정수검사를 추가했습니다.그리고 super user의 영역인데 super user는 하드코딩으로 넣어놨습니다. 관리자가 저밖에 없으니 굳이 디비로 만들 필요가 있을까 싶어서입니다. 다시 검색영역으로 돌아가면 ismodify 컬럼(69 line)을 보면 댓글이 본인 것이면 수정할 수 있고 본인 것이 아니면 수정할 수 없게 한 파라미터가 있습니다. 여기에 super 유저면 보든 댓글의 수정이 가능하게 바꾸려고 만든 부분입니다. super user도 검색뿐 아니라 수정, 삭제에서도 권한 검사를 하므로 필요할 것 같아서 공통에 넣었습니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/22c4b209f70d4f4b95b2bc822da6fc69.html</guid><pubDate>Sun, 02 Dec 2018 17:12:05 GMT</pubDate></item><item><title>[블로그 구축 13일차] 블로그 댓글 기능 달기 -4(서버 구축)</title><link>http://www.nowonbun.com/Dialy/32d7d7135654429faf3cbdfe618bae00.html</link><description> 데이터베이스 설계도 완료가 되었으니 이제 본격적인 코딩을 해야겠네요. 본래는 프로그램 설계를 하고 코딩해야 정상적인 프로젝트 흐름입니다만 복잡한 프로그램도 아니고 간단하니 바로 코딩했습니다. 서버 스크립트 사용 언어는 예전에 무료 호스팅 우비에서 사용하기로 했으니 php로 작성했습니다. 개인적으로 좋아하는 언어는 java와 C#같은 OOP(Object-Oriented Programming: 객체지향 프로그래밍)가 좋은데 무료 호스팅에서는 그 언어들을 지원하지 않네요. 왜 그럴까요? java도 무료 언어인데. 참 아쉽네요. 그렇다고 php가 성능이 떨어지는 언어는 아닙니다. 가볍고 빠르고 꽤 직관적인 언어라 구현이 매우 빠릅니다. 메모리 직접 참조가 없는데도 메모리 릭도 거의 없습니다.. 꽤 편리하고 좋은 언어입니다. 단점은 java처럼 메모리를 직접 관리하는 영역이 없어서 디자인 패턴 적용이 쉽지가 않습니다. 그리고 스레드를 직접 컨트롤할 수 있는 것도 아닙니다. 또 댓글 기능처럼 소형 프로젝트는 괜찮으나 대형 프로젝트로 가면 소스가 엄청나게 많아지기 때문에 관리도 만만치 않습니다.그러나 댓글 기능은 복잡한 프로그램을 하는 게 아니고 간단하게 글쓰기, 수정하기, 삭제하기 그리고 검색하기를 ajax로 값을 가져올 수 있으면 되기 때문에 php로도 충분한 것 같습니다. 구성은 다음과 같이 생각하고 있습니다.common.php - 공통 부분 (comment entity, abstract controller, db connection)add.php - 입력 부분modify.php - 수정 부분delete.php - 삭제 부분select.php - 검색 부분먼저 common.php를 만들겠습니다.
class Comment{
  private $idx;
  private $id;
  private $email;
  private $parent;
  private $createdate;
  private $lastupdated;
  private $comment;
  private $child;
  
  public function setIdx($idx){
    $this-&gt;idx = $idx;
  }
  public function getIdx(){
    return $this-&gt;idx;
  }
  public function setId($id){
    $this-&gt;id = $id;
  }
  public function getId(){
    return $this-&gt;id;
  }
  public function setEmail($email){
    $this-&gt;email = $email;
  }
  public function getEmail(){
    return $this-&gt;email;
  }
  public function setParent($parent){
    $this-&gt;parent = $parent;
  }
  public function getParent(){
    return $this-&gt;parent;
  }
  public function setCreatedate($createdate){
    $this-&gt;createdate = $createdate;
  }
  public function getCreatedate(){
    return $this-&gt;createdate;
  }
  public function setLastupdated($lastupdated){
    $this-&gt;lastupdated = $lastupdated;
  }
  public function getLastupdated(){
    return $this-&gt;lastupdated;
  }
  public function setComment($comment){
    $this-&gt;comment = $comment;
  }
  public function getComment(){
    return $this-&gt;comment;
  }
  public function setChild($child){
    $this-&gt;child = $child;
  }
  public function getChild(){
    return $this-&gt;child;
  }
}
 저는 프로그램 강좌 블로그는 아니니 따로 코딩 해설은 생각하겠습니다. 의미도 없을 것 같으니.. 위 클래스는 comment 클래스입니다. 이 클래스의 목적은 데이터베이스의 값을 가져와서 클래스로 담을 생각입니다. 댓글 하나의 정보가 하나의 클래스가 되겠네요. 여러 개의 데이터를 가져오면 comment 클래스를 리스트에 담아서 사용할 생각입니다. 그럼 sort나 값을 다루기도 편합니다. ORM 개념이라 java나 C#에서 많이 설계하는 형태입니다. 추가로 데이터 베이스와 다른 변수가 child가 있네요. 이건 Comment 클래스의 리스트를 넣을 생각인데 댓글의 하위 리플 댓글 리스트가 여기에 들어갑니다. php는 자료형을 선언하는 게 아니라서 소스만 보고는 어떤 데이터 형태가 들어가는지 확인하기가 어렵네요.
error_reporting ( E_ALL ^ E_NOTICE || E_WARNING );
class DBConn {
  private $hostname = "";
  private $username = "";
  private $password = "";
  private $dbname = "";
  public function get() {
    return new mysqli ( $this-&gt;hostname, $this-&gt;username, $this-&gt;password, $this-&gt;dbname ); 
  }
}
abstract class AbstractDao {
  private $db;
  private $mysqli;

  protected function getStmt($qy) {
    $this-&gt;db = new DBConn ();
    $this-&gt;mysqli = $this-&gt;db-&gt;get ();
    $stmt = $this-&gt;mysqli-&gt;prepare ( $qy );
    return $stmt;
  }
  protected function close() {
    $this-&gt;mysqli-&gt;close ();
  }
  
  public function execute(){
    header("content-type: application/json; charset=utf-8");
    header("Access-Control-Allow-Origin:*");
    return json_encode($this-&gt;run());
  }
  protected abstract function run();
}
 위는 먼저 데이터베이스 커넥션(DBConn)과 입력, 수정, 삭제, 검색의 상위 클래스(common)입니다. 네 가지 기능의 공통적인 함수를 common 클래스에 넣습니다. 일단 네 가지 모두 데이터 베이스 접속을 하는 것 같고, 웹 해더영역도 ajax로만 사용하기 때문에 같습니다. 그리고 우리는 cross 플랫폼이기 때문에 해더에 모든 사이트에서 허용한다고 해야 합니다. 이걸 안 하면 아마 ajax로 받아오는 곳에서 security 에러가 날 것입니다.  그리고 execute를 호출하면 하위 클래스에선 run함수가 호출하게 했습니다. 저는 항상 프로그램 설계를 할 때 하위 클래스(업무 영역)이 직접 호출하게 만들지 않습니다. 이유는 관리적인 문제 때문인데 하위 클래스를 직접 호출하는 영역이 많아질수록 에러가 발생했을 때 찾기가 어려워 지더라고요.. 이게 정답은 아니고 그냥 사람마다 스타일인데 저는 위와같은 방법을 선호합니다. 그리고 run에서는 array값을 리턴을 받고 array로 받으면 json으로 변환하여 리턴하는 형태로 만들었습니다. php가 함수 return 타입과 변수 타입을 선언하지 않기 때문에 코드만으로 무슨 값이 오는지 알 수가 없네요. 생각보다 가독성이 떨어집니다. 주석으로 설명을 해야 하나?저는 코드에 주석 다는 걸 별로 좋아하지 않기 때문에.. 아직 추상 설계만으로는 프로그램 흐름을 설명하기가 어렵네요..</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/32d7d7135654429faf3cbdfe618bae00.html</guid><pubDate>Sat, 01 Dec 2018 23:02:57 GMT</pubDate></item><item><title>[블로그 구축 12일차] 블로그 댓글 기능 달기 - 3 (DB 설계)</title><link>http://www.nowonbun.com/Dialy/commentDatabase20171130.html</link><description> 기본적인 자료조사는 끝났고, 이제 프로그래밍을 위한 첫 단계인 데이터베이스 설계를 하겠습니다. 데이터베이스는 처음 설계를 구축하면 후에 운영 중에는 바꾸기가 매우 어려운 영역입니다. 그래서 저는 가장 중요하다고 생각하는 부분이 설계라고 생각합니다. 설계 방식은 사람마다 방식이 다르고 구조도 많이 다릅니다. 구조를 설계하는 방법에는 데이터베이스 정규화라고 어느 정도 정해진 규칙이 있습니다. 그러나 실무에서는 요구사항과 차이가 있는 경우도 있고 로그나 성능을 위해서 반드시 정규화의 규칙을 따라서 설계할 필요는 없습니다. 가능하면 정규화에 맞추어서 만드는 것이 이상적이기는 하지만 상황에 따라 데이터 중복이나 레퍼런스를 연결 안 하는 경우도 있습니다. 그래서 설계는 딱 정해진 규칙이 없고 그냥 많이 만들어보고 많이 운영해보고 문제점을 느끼면 다음 설계부터는 고려해서 다시 설계하고... 데이터베이스 설계영역은 그래서 경험이 많이 중요하기도 합니다. 그럼 저는 어떻게 설계할지 다음과 같이 구상했습니다.
CREATE TABLE COMMENT_T(
  IDX INT NOT NULL AUTO_INCREMENT,
  URL NVARCHAR(255) NOT NULL,
  ID NVARCHAR(255) NOT NULL,
  IP NVARCHAR(255) NOT NULL,
  EMAIL NVARCHAR(255) NOT NULL,
  COMMENT NVARCHAR(4000) NULL,
  PARENT INT NULL,
  ISDELETED BIT DEFAULT 0 NOT NULL,
  CREATEDDATE DATETIME NOT NULL,
  LASTUPDATED DATETIME NOT NULL,

  PRIMARY KEY(IDX),
  FOREIGN KEY (PARENT) REFERENCES COMMENT(IDX)
);
CREATE TABLE COMMENT_H(
  IDX INT NOT NULL AUTO_INCREMENT,
  oIDX INT NOT NULL,
  URL NVARCHAR(255) NULL,
  ID NVARCHAR(255) NULL,
  IP NVARCHAR(255) NULL,
  EMAIL NVARCHAR(255) NULL,
  COMMENT NVARCHAR(4000) NULL,
  PARENT INT NULL,
  ISDELETED BIT NULL,
  CREATEDDATE DATETIME NULL,
  LASTUPDATED DATETIME NULL,
  HISTORYDATE DATETIME NOT NULL,

  PRIMARY KEY(IDX)
);

 스크립트를 보면 일단 마스터 테이블은 만들지 않았습니다. 트랜잭션 테이블 하나와 히스토리 테이블입니다. 두 테이블은 idx에 auto_increament 제약을 주어서 테이블 키로 설정했습니다. 그리고 url 컬럼은 어느 댓글 페이지인지 구분할 생각입니다. 그러니깐 location.origin + location.pathname 을 넣을 것입니다. location.href을 안 넣는 이유는 우리가 사용하는 페이지에 파라미터가 있으면 다른 페이지로 인식돼버리기 때문입니다. id와 email은 oauth로부터 받은 id를 넣을 것이고 ip는 client ip주소입니다. 혹시나 나중에 ddos 대책을 위해 넣어 놨습니다. comment는 댓글 내용이 됩니다. 그리고 parent는 self reference를 걸었는데. 여기는 댓글의 리플을 위한 컬럼입니다. isdeleted는 삭제할 경우 물리적 삭제가 아닌 논리적 삭제를 할 예정입니다. COMMENT_H의 테이블은 댓글 수정이 있으면 로그를 남겨놓기 위한 테이블입니다. triger는 작성하지 않고 소스 상에서 insert select 할 예정입니다. 왜냐하면 무료 웹 호스팅이다 보니 mysql버전이 낮습니다. 그러다 보니 triger로 예기치 못한 에러가 나올 수 있으니 최대한 안전하게 처리하기 위함입니다. 여기까지 데이터 베이스 설계가 완료되었네요. 다음은 댓글 서버스크립트(PHP)를 만들어야겠습니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/commentDatabase20171130.html</guid><pubDate>Sat, 01 Dec 2018 13:30:44 GMT</pubDate></item><item><title>[블로그 구축 11일차] 블로그 댓글 기능 달기 - 2 (구글의 oauth)</title><link>http://www.nowonbun.com/Dialy/oAuth20181130.html</link><description>블로그에 댓글 기능의 요구 사항은 정리가 되었습니다. 다시 정리하면, 먼저 "우버 사이트의 무료 웹호스팅을 통해서 ajax로 댓글을 만든다. 중간에 로그인 인증은 구글 oauth를 사용한다." 입니다.우선 웹호스팅의 데이터베이스 설계를 하기 전에 우리가 무슨 데이터를 취급하는지 조사를 할 필요가 있습니다. 댓글이니 우선 댓글 내용은 필요하고 어떤 사이트의 댓글인지 key가 필요하고, 또 누가 댓글을 썼는지 아이디의 정보가 필요합니다.그중 아이디의 정보는 대형 포털사이트를 로그인하면 oauth2의 인증시스템을 통해서 로그인에 대한 키 정보를 알려주는 시스템이 있습니다. 다시 말하면 우리가 회원 관리를 굳이 만들지 않아도 로그인 기능을 지원해주는 서비스입니다. 회원 정보 내용의 이름이던가 이메일주소 등등이 있습니다. 다른 뉴스사이트 등은 동시에 여러 인증을 사용하는데, 저는 그냥 구글 인증만 사용하겠습니다. 왜냐하면 나중에 지역화(Localization), 다시 말해 일본어 버전, 영어 버전도 만들 생각있습니다. 그 때 네이버나 다음의 포털사이트는 일본이나 미국에서는 사용하지 않습니다. 또 블로그 시스템을 언어별로 각기 개발하기보단 하나의 시스템으로 통합 관리하고 싶기 때문에 세계적으로 가장 많이 사용되는 구글 인증을 사용할 생각입니다.저만의 생각일 지도 모르겠는데 많은 유저들이 Google 아이디 하나쯤은 가지고 있을 거라는 추측이 있기 때문이고, 특히 Android의 playstore를 사용하려면 구글 아이디가 필요하기 때문에 많은 유저가 가지고 있을 거라 생각됩니다.먼저 구글 APi를 뒤적뒤적 찾아보았습니다.https://developers.google.com/identity/sign-in/web/위 링크를 통해 접속해보니 딱, 제가 필요한 소스가 예제로 작성까지 되어있네요. 보아하니 브라우저에 구글 아이디가 로그인되어 있으면 onSignIn의 함수가 실행되고 아니면 실행이 안 되는 구조입니다. 그러나 실행이 안 되는 건 조금 문제가 있을 것 같네요. 왜냐하면 로그인이 확인된 것은 내가 쓴 댓글과 댓글을 작성할 때 필요하지만 로그인이 안 돼 있는 것을 확인할 때는 어떻게 확인을 할지...그래서 뒤적뒤적해보니 스택 오버플로우에 저와 같은 고민으로 올린 글을 발견했습니다.https://stackoverflow.com/questions/31331428/how-to-call-getbasicprofile-of-google-to-google-signin-on-only-button-click이 두 소스를 응용해서 사용하면 제가 원하는 구조가 나올 것 같네요.다시 머릿속으로 구조를 정리해 보겠습니다.먼저 페이지가 load 되어있을 때 구글 로그인이 되어있으면 등록할 수 있는 텍스트 박스, 그리고 다른 댓글에는 replay 달기 버튼이 추가되고, 내가 작성한 댓글에는 수정과 삭제까지 가능하도록 동적으로 버튼을 만듭니다. 다음은 로그인이 되어 있지 않을 때는 로그인을 요구하는 구글 버튼이 보이고 등록하는 텍스트 박스는 disabled 해버립니다. 다른 댓글에도 replay 달기 버튼을 모두 숨기고, 당연히 로그인되어 있지 않으니 모든 댓글은 수정과 삭제 버튼이 숨겨져 있어야 합니다. 다시 댓글에서 로그인해서 송신하면 php 측에서 그 아이디와 패스워드를 받고 수정하거나 삭제, 등록하는 웹페이지를 하나 만들면 되겠습니다.그럼 구성은 어느 정도 완료가 되었고 데이터베이스를 설계하기 위해 데이터는 무엇이 있는지 살펴보겠습니다.Id 가 있고, Full Name, Email, token 등이 있네요.. 여기서 제가 필요한 데이터는 Id와 Email 뿐입니다. 다른 건 필요 없을 것같습니다.여기까지 했으면 oAuth의 조사는 끝냈습니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/oAuth20181130.html</guid><pubDate>Fri, 30 Nov 2018 01:09:33 GMT</pubDate></item><item><title>[블로그 구축 10일차] 소스 코드 보기 Grid 부착하기 highlight.js</title><link>http://www.nowonbun.com/Dialy/highlight20181128.html</link><description>댓글 시스템 만들다가 갑자기 다른 방향으로 좀 튀었네요.. 댓글 시스템 포스팅을 하다가 소스 내용이 조금 첨부가 될 것 같아서 급히 오픈소스를 추가하려고 합니다.소스 코드 보기 Grid가 무엇이냐면 우리 같이 프로그램 개발업계에서 일하고 있는 사람들은 웹 게시판에 글을 작성하다가 보면 간혹 소스코드를 올릴때가 있습니다.근데 소스코드를 덩그러니 게시가 되면 가장 기본적인 코드 라인이던가 코드 색깔 등이 보이지 않습니다. 간단히 말해, 우리가 쓰는 IDE 툴처럼 소스가 보이지 않고 메모장에 작성한 것처럼 보입니다.그렇게 하면 게시한 사람도 소스가 지저분해 보이고 보는 사람도 한 번에 분석하기가 힘듭니다. 흔히들 가독성이 떨어진다고 이야기합니다.그래서 오픈소스중에 highlight.js가 있는 데 오픈 소스를 link를 해놓고 pre 태그 안에 소스를 작성해 놓으면 깔끔하게 보입니다.간단히 말해 아래와 같이 보이게 됩니다.딱 보기에도 보기 편해 보입니다. 그럼 지금부터 제 블로그에 부착해 보겠습니다.highlight 홈페이지에 접속해서 사용법을 알아 보도록 하겠습니다.https://highlightjs.org/usage/들어가 보니 엄청 심플하네요.. 그냥 pre 태그 안에 code 태그를 작성하고 넣어봤습니다.결과 확인해 보니 제가 생각한 모습이 아닙니다..제가 생각한 모습은 줄번호도 있고 좀 더 심플한 모습일 거라 생각했는데 말입니다. 그래서 다시 구글링을 하다가 어떤 고수분이 highlight에 대해 포스팅을 해놓은 글이 있네요.참조 - http://lerv.me/25그 글의 내용은 highlight는 줄번호를 지원하지 않는다고 하는군요.. 예전에 제 기억으로는 되었던 거로 기억하는 데 말입니다.그래서 누군가가 github 줄번호가 나오게끔 만들어 놓았다고 합니다.. 얼른 가서 참조하겠습니다.https://github.com/wcoder/highlightjs-line-numbers.js/tree/master/src이번에는 줄번호가 나오긴 하는데... 나오기는 하는데... 우리가 상상했던 그런 모습이 아닙니다. 그래서 제가 직접 소스를 열고 확인해서 수정했습니다.그래서 다음과 같이 소스코드를 수정해 보았습니다.
		&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
	&lt;link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/rainbow.min.css" rel="stylesheet"&gt;
	&lt;style&gt;
	code {
		border: 5px solid #9280ff;
	}
	.hljs-ln-numbers {
		text-align: right;
		border-right: 1px solid #ccc;
		color: #999;
		-webkit-touch-callout: none;
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		user-select: none;
	}
	.hljs-ln-code .hljs-ln-line{
		margin-left: 10px;
	}
	.hljs-ln-numbers .hljs-ln-line{
		margin-right: 10px;
	}
	.code-title{
		background-color: #9280ff;
		padding-left: 10px;
		padding-top: 5px;
		color: white;
		font-weight: 800;
	}
	&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;pre&gt;
		&lt;code class="javascript" data-type="JAVASCIPT"&gt;
			function abc(){
				console.log("hello world");
			}
		&lt;/code&gt;
	&lt;/pre&gt;
	&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"&gt;&lt;/script&gt;
	&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"&gt;&lt;/script&gt;
	&lt;script src="highlightjs-line-numbers.js"&gt;&lt;/script&gt;
	&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
	&lt;script&gt;hljs.initLineNumbersOnLoad();&lt;/script&gt;
	&lt;script&gt;
		$("code").each(function(){
			$(this).before($("&lt;div class='code-title'&gt;&lt;/div&gt;").text($(this).data("type")));
		});
	&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
	
원래 타이틀 영역은 없었는데.. 제가 만들었습니다. 그리고 테두리도 심플하게 보라색으로 하고 번호와 소스간에 여백도 조금 넣었습니다.딱, 제가 원하는 스타일로 나오네요.. 앞으로 이렇게 써야겠습니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/highlight20181128.html</guid><pubDate>Wed, 28 Nov 2018 23:20:06 GMT</pubDate></item><item><title>[블로그 구축 9일차] 블로그 댓글 기능 추가 - 1 (요구분석)</title><link>http://www.nowonbun.com/Dialy/CommentSystem20181127.html</link><description> 이제 블로그를 시작한 지 약 1주일 정도가 지났는데.. 아직 글이 어수선하네요. 이번 블로그는 기술적인 내용은 생략하고 제가 프로그램 개발을 하면서 생기는 문제점과 고민을 적어서 공유하려고 했는데. 글솜씨던가 내용적인 면에서 아직 부족한 게 많습니다. 최근에는 블로그를 어떻게 만들어야 할까? 프로그램을 어떻게 개선해야 할까보다 글을 어떻게 써야 할까 하는 고민이 더 많은 것 같습니다. 아직 시작이기도 하니 시간이 지나면 조금 나아질까요? 이번 포스트부터는 블로그 댓글 기능을 달아볼 생각입니다. 예전에 이야기했듯 제 블로그는 블로그 호스팅이나 웹호스팅에서 구축한 것이 아닙니다. 그러다 보니 동적 웹 시스템이 개발되지 않고 오로지 정적으로만 개발이 되는 형태입니다.(정적 페이지라는 것은 html로 전개된 웹사이트입니다.) 그러나 포스트의 내용 같은 경우는 한번 작성만 하면 그다음부터는 수정할 내용이 거의 없기 때문에 정적으로만 해도 크게 힘들 것은 없는데. 문제는 댓글을 어떻게 처리할지 문제입니다. 댓글의 경우는 제가 작성하는 것이 아니고 제 글을 보는 불특정 유저가 제 글을 보고 밑에 코멘트를 다는 형태입니다. 그러면 먼저 제일 필요한 것이 유저가 댓글을 작성할 수 있는 텍스트 박스가 우선 필요하겠네요. 그리고 텍스트 박스에 글을 쓰고 저장하게 되면 그 내용을 받는 서버와 데이터베이스가 필요합니다. 최종적으로 다시 저장된 내용을 해당 블로그 밑에 표시가 되어야겠습니다. 여기서 제가 구성하는 형태는 github 내에서는 데이터베이스가 없기 때문에 어떻게든 해결이 되지 않습니다. 뭐 자바스크립트 내에서 github의 pull push가 가능하게 프로그래밍하면 가능하려나.. 가능하다고 하더라고 github 아이디를 가지고 있어야 하고 pull, push를 하면 모든 코멘트를 유저의 컴퓨터에 저장해야 하는 말도 안 되는 상황이 되겠네요. 그럼 어떻게 해볼까 고민하던 중에 ajax로 데이터베이스가 있는 다른 웹 서버에서 하면 어떨까 생각해봤습니다. 형태는 php + mysql가 좋겠네요. 그럼 php + mysql의 형태로 호스팅하는 데를 찾아보니 무료로 운영하는 업체가 꽤 있습니다. 그중 제가 살펴본 무료 웹 호스팅은 우비라는 곳입니다. 무료로 제공하는 옵션은 다음과 같습니다.하드용량 100M - 저는 ajax가 가능한 페이지만 만들 생각이기 때문에 그렇게 많은 하드 용량은 필요 없습니다.트래픽량 100M - 역시 json형태의 데이터만 주고받기 때문에 트래픽도 제약이 없습니다.mysql 무제한 제공 - 오... 이게 최고입니다.일일 히트 수 1만 - 이게 조금 걸리는 부분인데 1만 히트면 일단 1만 접속까지 제공하는 건데.. 아직은 1만은 꿈같은 이야기이니 그때 가서 생각해 봅시다. 웹 호스팅은 정했고 이제 어떻게 작성할 예정이냐면, 어차피 댓글 내용은 검색엔진에 걸리지 않아도 되는 영역입니다. 그러니 꼭 정적으로 html에 넣을 필요 없이 동적으로 html를 작성해도 괜찮습니다. 그럼 각 post 페이지에 ajax를 이용해서 위 댓글 사이트에 접속해서 url를 키로 댓글 데이터를 가져옵니다. 가져온 댓글 데이터를 jquery의 append 함수를 이용해서 동적으로 생성되게 만듭니다. 아! 그리고 익명은 제한하고 구글의 oauth인증을 써서 로그인한 유저가 댓글을 작성할 수 있게 해야겠습니다.이렇게 하면 댓글 기능이 만들어질 수 있을 것 같네요...우선! oauth 조사(아이디 키?)를 한 후에 데이터베이스 설계가 먼저 되어야겠네요...</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/CommentSystem20181127.html</guid><pubDate>Tue, 27 Nov 2018 23:04:36 GMT</pubDate></item><item><title>[블로그 구축 8일차] 블로그 최적화 2 (Open graph)</title><link>http://www.nowonbun.com/Dialy/Opengraph20181126.html</link><description>우리는 검색엔진에 필요한 매타태그를 블로그에 장착했습니다. 하루 동안에 갑자기 검색엔진에 상위 랭크되는 일은 일어나지 않네요..ㅎㅎ일단 제 대표 url로 되는 사이트에 결정적인 글의 수가 매우 부족한 게 원인이라고 생각됩니다.최소한 같은 대표 url(canonical 태그)에 혹은 sitemap이나 rss에 적어도 글이 100개 정도 돼야 상위랭크는 아니어도 조금씩 보이기 시작할 겁니다.제 경험상.. 예전 Tistory에서 운용할 때는 그랬던 거로 기억합니다. 그렇다고 한 번에 포스트를 밀어 넣으면 스팸 사이트로 인식해 버리는 경우도 있으니 역시 시간이 많이 필요한 작업이네요.신문이나 뉴스사이트는 어떨까요? 거기는 하루에도 수십 건의 기사가 올라올 것 같은데 검색엔진에 잘 올라오는 것 같은데.. 경험이 부족한 저로서는 아직 여러 시험을 거쳐봐야 할 것 같습니다.오늘은 전 일차와 같은데 매타태그를 등록하는 건 같은데, 검색보다는 편의를 위한 매타태그입니다.일단은 이 부분도 검색과는 거리가 조금 있지만, 사이트에 등록이 되어있으면 웹 마스터 입장에서는 사이트의 완성도가 높다고 판단되기 때문에 사이트 품질 쪽의 점수에서는 꽤 올라갈 듯싶습니다.최근 우리들의 IT접속 환경을 보면 예전 10년 전과 다르게 모바일도 꽤 많이 이용됩니다.모바일을 사용하면서 좋은 글이 있으면 친한 친구나 지인에게 url 링크를 걸어서 알려주기도 합니다.특히 카카오톡으로 url를 찍어서 보내면 링크 미리 보기 화면이 나오는데 이미지가 깨끗하게 나오는 경우도 있는가 한편 이상한 이미지가 깨지거나 요약 글도 엉성하게 표시되는 경우가 있습니다.이것이 Open graph를 설정했는지 안 했는지의 차이가 되겠습니다.위 이미지는 아직 Open graph를 등록시키지 않아서 이 블로그의 미리 보기가 엉망으로 나오는 걸 확인할 수 있네요.즉, Open graph는 대표 이미지와 요약 글을 알려주는 태그입니다.먼저 Open graph 태그가 무엇이 있는지 조사해 보겠습니다.http://ogp.me/제가 사용할 태그는 전부를 다 사용할 건 아니고, 필요한 것만 쓰면 될 것 같습니다.og:title - 표시될 제목입니다.og:description - 요약내용입니다.og:url - url입니다.og:site_name - 키워드 같은 것같습니다.og:type - 사이트 타입입니다. 이 경우는 블로그라는 타입이 없기 때문에 article을 넣겠습니다.og:image - 미리 보기에 표시될 이미지입니다.og:image:type - 이미지 타입입니다.(예: image/jpeg)og:image:width - 이미지 너비 사이즈입니다.og:image:height - 이미지 높이 사이즈입니다.og:image:alt - 이미지 설명입니다.그 외에도 많은 태그가 존재하는데 저는 필요없습니다.. 이제 제 블로그에 등록시켜 보겠습니다.우와... 예상은 했지만 이렇게 깔끔하게 나오니깐 또 블로그가 성장한 느낌이 드네요..</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/Opengraph20181126.html</guid><pubDate>Mon, 26 Nov 2018 23:01:54 GMT</pubDate></item><item><title>[블로그 구축 7일차] 에디터 수정하기 (SummerNote Image 입력 태그 수정...)</title><link>http://www.nowonbun.com/Dialy/SummerNoteModified.html</link><description>이번에는 블로그를 작성하는 에디터를 수정하겠습니다. 버그는 아니고 기존의 사양이 제가 현재 사용하는 사양과 조금 차이가 있어서 수정할까 합니다.아래의 이미지는 먼저 제가 사용하는 블로그 에디터입니다.제가 사용하는 에디터는 summernote라는 에디터 오픈소스입니다.https://summernote.org/잠깐 summernote에 대해 소개를 하면, 우리는 웹이라는 환경을 통해서 글을 작성하고 읽고 정보를 공유하는 데 많이 사용합니다. 그냥 글을 작성하는 데는 웹 태그인 testarea를 많이 사용합니다만 글에 많은 효과를 주기 위해서는 무언가 부족함이 있습니다. 그 글의 효과란 글자마다 폰트사이즈와 폰트를 달리할 수 있고, 사이즈를 변경할 수 있으며 링크를 달거나, 이미지까지 넣을 수 있는 에디트를 말합니다. 흔히 리치 텍스트 박스 또는 WYSIWYG 에디터라고도 이야기 합니다.인터넷이 찾아보면 많은 에디터 소스가 있습니다. 물론 가장 좋은 건 유료 에디터 소스가 가장 좋겠지만, 제가 유료를 쓸만할 정도의 여유는 없으니, 무료 오픈소스를 찾던중 Summernote 에디터가 가장 좋은 것 같습니다. 예전에는 fckeditor가 많이 사용했던 에디터 오픈소스로 저도 많이 사용했는데, 최근에는 업데이트도 없어서 저도 어느 순간부터는 사용하지 않게 되었네요. 그에 반해 summernote는 최근까지 업데이트가 있고 꾸준히 버그 리포트등도 있기 때문에 사용하면서 문제점이 발생해도 대응하기 좋습니다.제가 인식하는 에디터의 문제점을 찾아보겠습니다. 사실 문제점이나 버그가 아니고 제가 사용하는 사양에 대해 조금 버전 업을 하고 싶은 것입니다.위의 이미지를 보면 에디터에 이미지를 삽입할 수 있는 버튼이 있습니다. 이미지를 입력하면 아래와 같은 태그가 생성됩니다.위의 태그가 잘못되지는 않았는데.. 현재 블로그에서 사용하는 이미지 태그는 아래와 같이 사용하고 있습니다.그럼 우리가 해야 할 목표는 찾았고 어떻게 해야 할지 확인해 보겠습니다. 먼저 min형태의 압축된 소스가 아닌 일반 소스를 다운 받아서 찾아 확인해 보겠습니다. Summernote.js의 소스는 약 5000줄의 javascript이네요. 뭐 그렇게 많은 소스는 아닙니다만 우리가 img 태그하나 고치자고 4000줄 소스를 다 뒤지거나 디버깅을 할 수 없습니다.그렇다면 어떻게 인식하는 게 좋은지 생각해봅시다. 모든 프로그램은 표준 코딩방식이 있고 디자인패턴이 있기 때문에 특이하게 작성할 리는 없습니다. 그렇겠다면 상상해 보면 우리는 이미지 버튼을 누르고 이미지를 누르면 이미지 태그가 생긴다는 것을 인식할 수 있습니다. 그럼 조금은 찾기 쉬운 방식으로는 이미지 버튼 클릭 이벤트를 찾아보는 게 좋겠네요.그냥 단순히 img로 해서 글자 열 검색을 해보았습니다. 그랬더니 단번에 나와버리네요... 저는 image size를 넣는 부분을 제거하고 div를 생성하고 class를 넣었습니다.이번에도 크게 어려운 부분이 아니라 문제점 인식하고 바로 수정이 가능했습니다. 그래도 조금 전 단계와 다르다는 점은 제가 만든 소스가 아닌 오픈소스를 수정했다는 것입니다. 사람들은 오픈소스나 표준소스를 수정하기 두려워하는 사람들이 많습니다. 물론 상용 중인 시스템 내의 오픈소스를 수정하는 것은 리스크가 매우 큰 일입니다. 왜냐하면 우리는 오픈소스가 사용하는 레퍼런스들은 대부분 테스트가 검증된 소스들이기 때문에 수정한다는 것은 많은 부분을 테스트해야 한다는 조건이 따릅니다.그러나 반대로 오픈소스라도 버그가 없다는 100% 확신할 수 없기 때문에 표준 코딩방식과 디자인 패턴을 익혀서 많은 소스를 읽을 수 있는 혜안을 길러야겠습니다. 좀 더 어려운 문제가 생기면 좋겠네요..그래야 조금 더 많은 것을 해볼 수 있을 것 같습니다. 버그는 말고요....ㅠㅠ</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/SummerNoteModified.html</guid><pubDate>Sun, 25 Nov 2018 23:19:03 GMT</pubDate></item><item><title>[블로그 구축 6일차] 중간 버그 수정(IE 대응, Image, 매타태그 에러, 추가사항)</title><link>http://www.nowonbun.com/Dialy/04befa464ea84cb69ccd2706cdfdc425.html</link><description>원래는 블로그 최적화를 끝내고 나서 버그 수정을 하려고 했는데 너무 눈에 거슬려서 버그 수정을 하고 다음을 진행하겠습니다.지금 파악한 부분은 IE 대응 부분입니다.저 같은 경우는 Chrome을 주요 디버그 툴로 이용하기 때문에 화면이 Chrome에 최적화가 되어있습니다.Chrome을 디버그 툴로 이용하는 이유는 Chrome 사용자가 예전보다 늘었고 한국의 경우는 아직 IE를 사용하는 경우가 많은데..IE의 경우는 디버그 툴로 이용하기에는 너무 느리고 Firefox보다는 많이 사용하는 Chrome을 선택했습니다.그러나 Chrome을 최적화라고 생각한다고 해서 safari나 IE를 무시할 수 없기 때문에 중간중간 생각과 다른 디자인이 되지 않나 살펴봐야 합니다.그러다 IE에서 테스트를 하던 중 밑의 최신 글 항목에서 Chrome과 다른 형태의 디자인을 발견했습니다.원인은 Bootstrap의 row class 때문인데. 이게 li 태그 안에서 Chrome과 IE에서 동작하는 형태가 다르네요... 확인했으니 수정하겠습니다.그다음은 Image인데..현재 블로그 안에서 모든 Image는 680 X 340의 형태로 고정이 되어있습니다. 모바일에서는 확대 축소가 PC보다는 쉽기 때문에 확대해서 보기 쉽지만, PC의 경우는 그게 쉽지가 않기 때문에 조금도 보기 쉽게 수정해야겠습니다.w3school 사이트에 가보니 bootstrap으로 된 예제 소스가 있네요..https://www.w3schools.com/howto/howto_css_modal_images.asp이걸 그대로 쓰기에는 저와 환경이 다르기 때문에 자바스크립트를 수정했습니다.위 이미지를 클릭해보면 이미지가 확대되어서 보이는 것을 확인 할 수 있습니다.그리고 전 포스트에서 제가 메타태그를 붙였는데..네이버 웹 마스터에서 에러가 나는 것을 확인 했습니다.이게 제가 메타태그를 잘못 인지해서 발생한 에러이네요.Description 태그에 본문 내용을 전부 넣으면 좀 더 검색엔진에 좋을 것 같다는 생각이 들어서 입력한 것인데 오히려 에러가 발생했네요.리스트에서는 컴파일러에서 정한 데이터를 넣었는데...수정내용은 포스트 태그에도 리스트와 같이 정한 데이터를 넣으면 문제가 해결될 것 같습니다.홈페이지는 수정은 완료했지만, 웹 마스터의 재등록은 아마 시간이 걸릴 것입니다.블로그를 시작하고 첫 버그 수정이었습니다. 워낙 간단한 버그 수정이라 어떻게 해결하는 방법이 너무 단순하게 나와버렸네요.그냥 문제점 파악, 해결 식으로.. 좀 너무 간단하네요... 복잡한 버그가 나오면 안 되겠지만...그래도 포스트를 쓰기 위해 좀 복잡한 버그가 필요하긴 하네요... 고민해봐야겠습니다...</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/04befa464ea84cb69ccd2706cdfdc425.html</guid><pubDate>Sun, 25 Nov 2018 00:30:50 GMT</pubDate></item><item><title>[블로그 구축 5일차] 블로그 최적화 1 (매타태그)</title><link>http://www.nowonbun.com/Dialy/c2a8d6de887a4f399d4797e5ca05ecf5.html</link><description>애널리틱스를 블로그에 부착했고 웹 마스터에도 블로그를 등록했습니다.아직 네이버와 다음에 사이트 등록은 하지 않았습니다. 그렇지만 그것은 포스트 내용이 조금 늘어난 후에 등록해도 늦지 않다고 생각돼서 일단 우선순위를 조금 미룰 생각입니다.다음 해야할 일은 이제 구글이나 네이버에서 크롤링을 좀 더 정확하기 위해 웹사이트에 매타태그를 붙일 생각입니다.잠깐 크롤링이 어떻게 움직일까 생각해 봤습니다. 아마도 배치프로그램으로 데이터베이스에 등록된 사이트의 주소로 소켓을 이용한 httpconnection이나 Http 랜더링 엔진(예: Gecko)를 통해 웹페이지를 수집하지 않을 까 싶습니다.이때 우리가 그냥 div태그를 이용해서 글을 작성하면 크롤링은 페이지에 작성된 글에 대해 어떤 정보를 가졌는지 파악하기 힘들 것 같네요.우선 중요한 태그는 Title과 Article 그리고 h1~h6입니다.Title 태그는 브라우저의 창에도 표시되는 만큼 가장 중요하고 그다음은 기사 내용 article과 부제목 역할을 하는 h1~h6입니다. 그래야 크롤링이 여기 태그에 있는 글은 기사구나 제목이구나를 인식할 수 있습니다.그리고 크롤링이 글들을 수집해서 분석까지 해주면 너무너무 좋겠지만, 현실적으로 세계에 퍼져있는 사이트가 엄청 많기 때문에 분석하기야 하겠지만 시간이 오래 걸립니다. 특히, 제 블로그 같은 경우는 이제 시작한 시기이기 때문에 우선순위가 매우 낮아서 분석하지 않을 가능성도 매우 높습니다.즉, 제 블로그가 매우 높은 트래픽을 유지하면 구글이나 네이버 입장에서도 신경 쓰겠지만, 지금 시점은 아니란 소리죠.그래서 제가 크롤링이 좀 더 분석하기 쉽게 하기 위해 어느 정도 글 요약을 해줘야 하겠습니다.그 태그가 canonical, alternate, description, keyword, author, distribution, copyright, robots 태그입니다.먼저 canonical은 대표 url입니다. 지금 이 블로그 주소만 보더라고 각자 고유의 웹페이지가 존재합니다. 이렇게 해서는 크롤링이 각기 다른 사이트로 인식하지는 않겠지만 그래도 명시를 해주면 빨리 인식을 할 수 있습니다.alternate의 경우는 rss나 sitemap의 링크 주소입니다. 등록은 했지만 그래도 크롤링에 직접 알려줍시다.description는 페이지의 본문 글의 요약 글입니다. 이건 rss에서 썼던 description에 들어간 값이 들어가면 좋겠네요.keyword는 검색엔진에서 좀 더 검색키워드로 캐치할 수 있게 하는 키워드 목록입니다.author는 작성자입니다만 그냥 작성자 이름을 넣으면 될 거 같네요.. 저는 email을 넣을까 합니다.distribution, copyright는 그렇게 중요하지는 않지만 일단 똑같이 제 email을 넣겠습니다.robots는 크롤링의 허용태그인데.. 저는 무조건 all로 할 예정입니다.이렇게 작성해 놓으면 크롤링이 사이트를 검색할 때 좀 더 정확하게 또 따로 분석이 없이 빠르게 검색엔진에 등록될 것입니다.실제는 어떨까요? 시간을 두고 하나하나 실험을 해보아야겠습니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/c2a8d6de887a4f399d4797e5ca05ecf5.html</guid><pubDate>Sat, 24 Nov 2018 00:46:01 GMT</pubDate></item><item><title>[블로그 구축 4일차] 웹마스터 등록하기...(rss, sitemap)</title><link>http://www.nowonbun.com/Dialy/8b6c0fc7f7624c37a4e30d9e8e012230.html</link><description>앞에서 애널리틱스를 블로그에 붙였으니 이번에는 웹 마스터에 블로그를 등록하겠습니다.애널리틱스는 방문객 접속 분석 툴이면 웹 마스터는 검색엔진에 내 사이트에 무슨 내용이 있다고 등록하는 것입니다.구글의 경우는 크롤링이라는 웹 수집기가 존재해서 따로 웹 마스터를 등록하지 않아도 시간이 지나면 검색엔진에 노출이 되고 검색됩니다.그러나 그럴 경우 시간이 매우 많이 걸리기 때문에 우리는 웹 마스터에 블로그를 등록시킵니다. 그렇게 해서 크롤링이 좀 더 효과적으로 데이터를 수집해가고 그 내용을 이용해서 검색엔진의 상단에 글을 올릴 수 있습니다..구글 검색 결과, 애널리틱스처럼 웹 마스터 역시 가장 많이 등록시키는 것은 구글이고 그다음이 네이버인 듯싶습니다.두 웹 마스터에 우리는 sitemap과 rss를 등록해야 합니다.먼저 sitemap을 살펴보면, sitemap은 내용의 정보보다는 사이트의 구조의 중심으로 되어있고 url, 중요도 등이 등록된 xml 문서입니다.https://www.sitemaps.org/ko/protocol.html그 다음은 rss에 대해 살펴보겠습니다.rss의 경우도 sitemap와 구조는 비슷합니다만 sitemap보다는 조금 더 자세한 내용이 기술되어있네요. 각 column에 description항목이 있어서 각 사이트의 요약내용을 수집해 갈 수 있는 feed입니다.https://validator.w3.org/feed/docs/rss2.htmlrss의 표준 구조체도 표준 사이트에서 확인해 봅시다.구글을 검색해 보니 사이트 url를 치면 사이트를 분석해서 sitemap과 rss를 생성해주는 사이트도 존재합니다.그러나 저 같은 경우는 매일 글을 갱신하고 업데이트가 되는데 할때마다 사이트를 분석해서 sitemap과 rss를 만드는 것이 더 시간이 걸리고 귀찮을 것 같습니다.그리고 제 블로그 시스템은 html를 output 해주는 배치프로그램이 있습니다. 그 배치프로그램에서 html를 생성할 때 rss와 sitemap도 같이 생성하게 수정하면 따로 sitemap과 rss를 분석해서 생성하지 않아도 만들어 낼 수 있을 것 같습니다.배치 프로그램의 url주소는 다음과 같습니다.https://github.com/nowonbun/BlogCompiler프로그램의 구조는 entity orm을 이용해서 데이터베이스의 형식을 클래스 형식으로 변환을 했습니다. 그렇기 때문에 output 데이터 한두 개 추가하는 건 그리 어렵진 않네요. 다 만들고 나서 출력을 해보니 잘 나오네요.이제 실제 github에 등록시키고 제대로 나오는지 확인해 봐야겠습니다.sitemap - http://www.nowonbun.com/sitemap.xmlrss - http://www.nowonbun.com/rss이제 이것을 구글과 네이버 웹 마스터에 등록하겠습니다.[구글 웹 마스터 화면][네이버 웹 마스터 화면]웹 마스터라는 것은 등록한다고 바로 검색엔진에 상위랭크되고 최적화가 이루어 지는 건 아닙니다. 단지 크롤링이 작업하는 데 도움이 되는 것일 뿐.그러니 등록을 한다 해도 제 글들이 검색엔진에 보이기 까지는 시간이 조금 걸릴 듯싶네요..아직까지 검색엔진을 통한 방문객은 0입니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/8b6c0fc7f7624c37a4e30d9e8e012230.html</guid><pubDate>Fri, 23 Nov 2018 00:00:00 GMT</pubDate></item><item><title>한국어 맞춤법/문법 검사기</title><link>http://www.nowonbun.com/Favorites/speller20181122.html</link><description>안녕하세요.. 오늘 소개할 사이트는 맞춤법 교정사이트입니다.http://speller.cs.pusan.ac.kr/우리가 문서를 작성할 때 또는 저는 블로그 포스팅을 작성할 때 등, 주위에서 글을 작성할 때가 매우 많습니다.그런 상황에서 내가 작성한 글을 다른 사람에게 확인을 받거나 맞춤법을 검사받기가 쉽지 않습니다. 저의 경우에도 포스트에 글을 올리기 전에 맞춤법이 맞는지 확인을 하고 싶은데 환경이 쉽지 않습니다.특히 자기가 작성한 글에 틀린 점을 찾기는 어렵고 다른 사람에게 부탁하자니 모두 바쁘기도 하고, 저는 블로그에 매일매일 글을 올려야 하는 상황인데 매일 검사를 받기 위한 환경을 만들기가 어렵습니다.맞춤법은 글을 쓸 때 매우 중요하다고 생각합니다. 왜냐하면 우리가 글을 읽다가 오타를 발견하면 왠지 그것에 신경이 엄청나게 쓰이면서 글이 눈에 안 들어올 때가 많습니다.그래서 기본 중의 기본, 잘해야 본전인 것이 맞춤법이라고 생각합니다.그래서 저는 맞춤법을 검사해주는 시스템이 있지 않을까 생각하면서 찾다가 찾은 사이트가 여기입니다. (이 사이트가 딱히 명칭이 없어서 여기라고 표현 했습니다.)여기는 처음 들어갈 때는 다른 사이트처럼 이쁜 디자인이나 광고 등은 전혀 없이 맞춤법 기능만 있는 사이트라는 점이 매우 인상적입니다.아래에는 부산대학교 인공지능 연구실과 함께 만든다고 쓰여있는 것을 보니, 제 생각에는 문자 인공지능과 관련된 시스템인 것 같습니다.우리가 구글에서 맞춤법 검사의 키워드로 검색하면 많은 맞춤법 교정 사이트가 있습니다. 특히 인크루트 등에서 많이 제공하네요.. 이력서를 쓸 때 아무래도 맞춤법이 중요하니까요. 각기 장점은 있겠지만 타 사이트는 수정만 해주고 무엇이 틀린지 정확한 해설이 부족한 반면, 여기는 왜 틀린지 해설도 해주는 부분이 매우 인상적입니다. 국어 공부할 때도 도움이 될 것같네요.그러나 여기 사이트의 단점이라고 생각하면 한 번에 많은 글을 검사를 못 하는것 같아요 최대 1000자 내외 정도. 그래서 긴 글을 검사할 때는 나누어서 검사해야하는 불편함이 있습니다.그럼 맞춤법을 한번 검사해 보겠습니다.검사를 하게 되면 왼쪽에는 교정대상이 있고 오른쪽에는 교정설명이 있습니다.교정 내용이 비교적 잘 설명이 되어있어서 맞춤법 공부하는 데도 도움 되네요.. 한글 맞춤법이라는 게 공부를 해도 해도 틀리는 게 맞춤법이니깐요.여기까지 맞춤법 사이트의 소개였습니다. 많은 사람이 이 사이트를 잘 활용했으면 좋겠네요..</description><category>즐겨찾기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Favorites/speller20181122.html</guid><pubDate>Thu, 22 Nov 2018 22:29:42 GMT</pubDate></item><item><title>[블로그 구축 3일차] 블로그 분석 툴(애널리틱스) 구성하기...</title><link>http://www.nowonbun.com/Dialy/analytics20181121.html</link><description>먼저 이 아무것도 없는 블로그에 제가 해야 할 일은 애널리틱스를 설치하는 것입니다.애널리틱스란 이 블로그에 얼마나 많은 접속자가 어디에서 몇 시에 어느 페이지를 어떤 경로로 들어오는지 확인할 수 있고 분석을 해 주는 툴입니다.애널리틱스를 통해서 내 블로그에 주요 접속하는 유저는 어떤 사람이고 어떤 글에 많은 흥미를 보인다고 분석할 수 있습니다. 그것을 통해 관련 글을 더 보강하고 또 확장해서 그와 관련된 사람들과 소통도 할 수 있고 더 많이 유입을 시킬 수 있습니다.정리하자면 애널리틱스를 통해 블로그 자체는 어떻게 홍보할 것인지 어떤 방향으로 가야 할 것인지 생각할 수 있게 도와주는 툴이리고 보면 되겠습니다. 저는 따로 블로그를 홍보할 생각은 없습니다만 적어도 어떻게 유입이 되는지 알아야 우리가 나중에 검색엔진의 상단에 어떻게 올릴지 작전을 짤 수 있을 것같습니다.그럼 애널리틱스를 제 블로그에 설치해 보겠습니다. 구글에서 검색해 보니 애널리틱스는 구글과 네이버 애널리틱스에 대한 내용이 많네요. 그중 구글 애널리틱스가 가장 많이 사용하고, 그다음에는 네이버 애널리틱스가 사용되는 것같습니다..다음은 애널리틱스가 없나요? 제가 검색해 본 결과에는 나오지 않네요.그럼 구글 애널리틱스를 먼저 설치하기 위해서 먼저 구글에서 애널리틱스를 검색해서 로그인합니다.그리고 제 블로그 사이트를 등록하면 애널리틱스에서 3~4줄짜리 코드를 줍니다.그 코드를 제 블로그 사이트 최상단에 넣으면 되겠습니다.head 태그 맡으로...두번째 네이버도 설치해보겠습니다. 네이버 애널리틱스도 구글에서 검색합니다.먼저 사이트 등록을 하면 분석 스크립트를 주네요..이 분석 스크립트를 head 태그의 google 애널리틱스 밑에다가 넣겠습니다.그럼 구글 애널리틱스와 네이버 구글 애널리틱스에 대해 조금 살펴보겠습니다.구글의 경우는 실시간, 잠재고객, 그리고 모바일에 대한 접속 정보도 있네요.개인적인 생각입니다만, 구글의 경우는 너무 많은 정보가 있지 않나 생각되네요. 오히려 정보가 너무 많아서 사용하기 어렵다는 느낌이 강합니다. 예를 들면 메뉴 중에 벤치마킹이 있는데 이것은 무슨 의미일까?정작 내가 필요한 오늘 접속자와 시간별, 기기별 등의 내용은 어디있는지 모든 메뉴를 찍어봐야 알 수 있네요..다음은 네이버 애널리틱스를 살펴보겠습니다.내용자체는 굉장히 심플하네요.. 구글에서 제가 찾기 힘들다는 부분도 확실히 찾기도 쉽고 편리합니다.그러나 이건 역으로 정보가 상당히 부족하지 않나 느낌이 강합니다.아직까지는 네이버 애널리틱스를 많이 사용해 보지 않아서 어떤 게 더 편하고 좋다라고 비교하기는 힘듭니다. 한 6개월 이상 사용해보고 기회 있을 때 리뷰를 해봐야겠네요.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/analytics20181121.html</guid><pubDate>Wed, 21 Nov 2018 22:43:11 GMT</pubDate></item><item><title>이미지 용량 줄이는 사이트 - tinypng.com</title><link>http://www.nowonbun.com/Favorites/tinypng.html</link><description>안녕하세요. 오늘 소개할 사이트는 이미지 용량 줄이는 사이트입니다.https://tinypng.com/저는 블로그를 운영하니깐 이미지 활용이 매우 많습니다. 그러나 꼭 블로그 운영뿐 아니라 회사 문서를 작성하거나 프로젝트 과제 작성 등을 할 때도 이미지를 많이 사용합니다.그러나 그 이미지들이 고품질의 고화질로 사용하면 매우 좋지만, 웹사이트이니만큼 용량과 속도에도 생각을 안 할 수 없습니다. 꼭 웹사이트가 아니더라도 문서를 작성하는데 용량이 큰 이미지를 첨부시켰더니 파일 용량이 100메가 이상 된 적도 있습니다. 이런 문서들은 문서를 열 때도 시간이 느리고 메일 보내기 등 많은 부분에 제약이 걸리게 됩니다. 단지 이미지 한두 개 때문에..우리가 사진 전시회를 하지 않는 이상 문서에서나 웹사이트에서 쓰는 이미지는 고품질, 고화질 이미지가 필요 없습니다. 거의 문서 내용을 조금 더 정확하게 전달하거나 또는 글만 있는 문서는 읽다가 질리기 쉬운데, 그런 문제를 해결을 위해 이미지를 사용하는 경우가 많이 있습니다.그래서 소개할 사이트는 tinypng입니다. tinypng사이트에서 이미지 용량 줄이는 파일은 png, jpg만 취급합니다. 만약 bmp 등 다른 이미지 파일이면 png나 jpg로 변환시켜야 합니다.먼저 테스트해 볼 이미지를 준비하고 끌어넣기를 하겠습니다.저 같은 경우는 230kb의 이미지의 용량을 줄여 보았습니다.거의 50% 이상 줄어 드네요..재미로 줄인 파일을 더 줄여 보겠습니다. 계속 줄어듭니다.이미지 화질도 많이 안 좋아질 줄 알았는데.. 그렇게 차이는 없네요...그러나 크게 용량이 줄어든 것은 첫 번째뿐입니다. 두 번째부터는 조금씩 줄어드네요. 그래서 두 번째 이상은 할 필요가 없을 것 같습니다.</description><category>즐겨찾기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Favorites/tinypng.html</guid><pubDate>Tue, 20 Nov 2018 22:35:11 GMT</pubDate></item><item><title>[블로그 구축 2일차] 블로그 구성에 대해...</title><link>http://www.nowonbun.com/Dialy/BlogStructure20181119.html</link><description>먼저 앞 포스팅에서 문제점을 파악하고 우선으로 해야 할 일을 생각했었습니다.그러나 우리가 앞으로 블로그 구축이라는 프로젝트를 하면서 느끼는 점을 공유하기 위해서는 먼저 이 시스템에 대해 설명할 필요해야 할 것 같습니다.이 블로그(www.nowonbun.com)를 운영하는 웹호스팅은 Github(https://github.com/)에서 운영하고 있습니다.Github의 원래의 목적은 웹호스팅이 아니고 소스 버전 관리 툴입니다.소스 버전 관리란 svn과 비슷한 건데.. 우리가 흔히 프로젝트 할 때 커밋 또는 업데이트하는 툴이라고 생각하면 됩니다.원래의 목적은 소스 버전 관리가 맞습니다만 이 github.com은 html을 올리면 웹호스팅 기능까지 제공합니다.그런데 많은 웹호스팅, 블로그 호스팅이 있음에도 github.com를 선택한 이유는 예전 tistory와는 다르게 해외 트래픽도 꽤 안정적으로 빠르기 때문입니다.tistory가 일본에서 접속하면 꽤 느려요. 구글 웹 마스터에서는 사이트의 접속 속도도 체크하기 때문에 한국 구글의 검색엔진에는 무난하게 상위 랭크가 되겠지만 외국에서는 상위 랭크가 절대 되지 않습니다.즉, tistory에서 영어로 된 블로그를 만들어도 국내에서만 검색이 되고, 일본 구글이나 미국 구글에서는 검색이 되지 않을 확률이 높습니다.네이버 블로그는 왜 그런 정책을 했는지는 몰라도 구글에서 검색 순위가 매우 낮습니다.이 블로그의 계획은 처음에는 한글로 된 블로그로 시작하지만 나중에는 확장해서 영어, 일본어로 만들 생각이 있기 때문에 github.com에 자리를 잡았습니다.그렇지만 github.com는 다른 사람에게는 추천할 만한 호스팅 사이트는 아닙니다.왜냐하면 먼저 git에 대한 지식이 없으면 절대 사용할 수 없습니다. 개발자들은 프로젝트를 하기 위해 소스 버전 관리가 필요하기 때문에 경력이 조금이라도 있으신 분들은 git를 무난하게 익히고 사용할 수 있습니다. 그러나 프로그램을 모르는 초심자들은 git를 사용하려면 아주 어려울 것입니다. 공부해야 할 게 많습니다.그리고 git의 웹 호스팅은 다른 블로그 호스팅처럼 디자인 테마나 템플릿을 제공하지 않습니다.그래서 여기서는 처음부터 만들어야 합니다. 이 블로그 역시 디자인부터 제가 다 만든 것입니다. 그래서 첫 구축에 많은 노력과 시간을 사용했었습니다.그리고 여기까지도 프로그램을 잘 사람은 크게 제약은 없습니다. 그러나 git에서 블로그를 운영하기 어려운 이유가 데이터베이스가 없습니다.그리고 웹호스팅도 web api 스크립트로 이루어진 동적 페이지가 아닌 오로지 html 정적 페이지이기 때문입니다.즉, 데이터를 Html형태로 변환해주는 툴을 만들어야 합니다.저는 이 블로그를 위해 로컬에서 글을 쓸 수 있는 에디터를 만들었고, html로 output하는 배치프로그램을 만들었습니다.여기까지가 제 블로그의 구성에 대한 간략한 설명이었습니다.이런 불편함을 감수하고서라도 github를 사용해야 한다면 아래에 제가 만든 에디터와 output하는 배치프로그램 소스가 있으니 한번 사용해 보세요.[Blogeditor]https://github.com/nowonbun/Blogeditor[Blogcompiler]https://github.com/nowonbun/BlogCompiler이제 블로그 구성에 대해서 설명했으니, rss와 sitemap.xml을 구축해 봐야겠습니다.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/BlogStructure20181119.html</guid><pubDate>Mon, 19 Nov 2018 22:41:17 GMT</pubDate></item><item><title>[블로그 구축 1일차] 현재 문제점 파악하기...</title><link>http://www.nowonbun.com/Dialy/BlogStart1.html</link><description>우선 일을 시작하면 새로운 것을 만들 때는 그것을 왜 만드는지, 기존한 것을 수정할 때는 무슨 문제가 있어서 수정하는지를 파악하는 게 우선이라고 생각합니다.그래서 제가 가장 먼저 하고 싶은 일은 여기 블로그를 많은 방문객이 오는 활성화가 되고 오류도 없는 정상적인 블로그 사이트 버전을 만들고 싶습니다.먼저 여기 블로그의 플랫폼에 대해 설명하면 Github라는 프로그램 소스 저장소에 html을 등록시켜 웹 호스팅으로 전환한 사이트입니다.세세한 방법에 대해서는 기회가 된다면 명월 일지에서 소개하겠습니다.먼저 이 시스템의 문제점은 웹서비스를 할 때 우리가 흔히 다루는 웹 애플리케이션 서버(WAS)가 아니라 단순 웹서버이다 보니 동적 웹서비스를 구축할 수 없습니다.그래서 이 시스템은 로컬 mysql에 포스트 내용을 등록을 시키고 데이터 베이스에서 데이터를 가져와서 html을 생성하고 생성된 html을 github에 커밋을 해서 운영하고 있습니다.그렇게 불편한 github를 운영하는 이유에 대해서는 트래픽이 속도 때문입니다. 제가 알고 있는 플랫폼 중에서는 Google blog과 github가 가장 빠른 것 같습니다.그래서 현재의 문제점은 보통 블로그 플랫폼에서 제공하는 기능에 대해서 지금 블로그에는 하나도 없다는 게 문제입니다. 제가 손수 다 설치해야 하고 프로그램을 만들어야 합니다.지금 우선적으로 구글과 네이버의 아날리틱스, 웹 마스터 등록, 댓글 기능 추가 등등이 빨리 해야할 부분이라고 생각됩니다.그중에서 제일 시급히 해야 할 일은 웹 마스터 등록과 아날리틱스 등록입니다.웹 마스터 등록을 하는 이유는 검색 포털 시스템에 제 블로그를 노출하기 위해서 입니다. 제가 고민해서 쓴 글들이 아무도 읽지 않는다면 의미가 없잖아요..그래서 검색엔진에 등록을 시키는 작업이 웹 마스터 등록입니다.먼저 대표적인 검색 포털 시스템인 구글의 경우는 sitemap.xml를 등록하면 웹 마스터에 등록이 됩니다.그러나 네이버의 경우는 rss를 제출해야 합니다. 구글의 경우도 rss를 제출해도 되긴 하는데, 도움말에는 sitemap.xml을 제출하라고 설명되어 있으니 그대로 하는 게 좋을 껏 같네요.아날리틱스는 접속 현황을 분석할 수 있는 도구 툴입니다. 이 경우도 구굴과 네이버가 둘 다 존재합니다만 이상하게 서로 제출되는 데이터는 항상 다릅니다.왜 그런지는 저도 기억이 나질 않네요.. 나중에 기회 있으면 한번 같이 분석해 봅시다.제가 왜 이 두 작업을 가장 우선으로 처리하는 가하면,예전에 제가 2년 전에 일본 블로그를 운영한 적이 있습니다. 그때 초창기에 웹 마스터를 등록하지 않고 블로그를 운영했습니다.왜냐하면 글도 많지 않고 지금과 같이 한창 구축에 열을 올릴 단계여서 크게 필요하지 않는다고 생각되어서 그랬습니다. 그렇게 깜박 잊고 약 2~3개월을 운영했네요.그런데 신기한 게 웹 마스터를 등록하지 않고도 구글 크롤링이 탐색한 것인지 구글 검색에 노출이 되기 시작하더라고요. 그때 웹 마스터를 달아야겠다고 생각하고 작업을 했었습니다.그런데 갑자기 검색 결과에 제 블로그가 싹 빠져버렸더라고요. 이리저리 검색을 해봤는데도 명쾌한 답을 주는 곳도 없고..느낌이 검색엔진에 웹 사이트에 대한 검색 노출 데이터? 인텍스?가 있는 거 같은데 늦게 웹 마스터를 등록해서인지 검색 데이터가 초기화되어 버린 느낌이 들더라고요.어쨌든 검색엔진에서 블로그 노출이 조금씩 되던 것이 갑자기 되지 않다 보니 순간 흥미를 잃어버리고 다시 겨우겨우 회생시켜보려다가 그대로 포기해 버린 경험이 있습니다.그래서! 이번에는 웹 마스터부터 등록해서 나중에 검색엔진에서 갑자기 빠져버리는 현상을 방지하기 위해 최우선의 작업으로 설정했습니다.이제 저는 sitemmap.xml를 살펴 봐야겠네요.</description><category>개발일기</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/Dialy/BlogStart1.html</guid><pubDate>Mon, 12 Nov 2018 23:27:49 GMT</pubDate></item><item><title>블로그를 다시 시작하며...</title><link>http://www.nowonbun.com/index.html</link><description>안녕하세요.저는 예전에 명월일지(http://nowonbun.tistory.com) 의 블로그로 활동했던 명월입니다. 약 4년 만에 블로그를 다시 시작하는 것 같네요.처음 약 10년 전에는 네이버에서 블로그를 시작하여, 6년 전에는 티스토리로 옮기고 다시 4년 전부터는 블로그 활동을 거의 접다시피 활동이 없었습니다.가끔 티스토리의 포스트에 댓글이 달리거나 메일이 오면 답신을 하지만 실질적인 포스트 업데이트는 없었습니다. 활동이 그렇다 보니 관리도 소홀해지고 디자인도 점점 엉망진창이 되고 많이 망가지면서 현재에 이르게 되었습니다.마음 같아서는 예전에 공들여서 만든 블로그를 다시 살리고 싶은 마음인데, 지금으로써는 어떻게 해야 할지 엄두가 나지 않습니다.그래서 고민한 결과, 우선 명월 일기라는 타이틀로 블로그를 다시 시작하면서 예전의 블로그를 조금씩 조금씩 수정하면 어떨까 하는 생각으로 이 블로그를 시작하게 되었습니다.일기와 일지의 어감이 발음이 비슷하면서도 의미상으로 차이가 있습니다. 일기는 활동한 일에 대한 느낌과 감정을 작성하는 것이고 일지는 업무 등의 중요한 일을 좀 더 객관적으로 작성하는 것이지 않을까 싶습니다. (저의 생각이니 다를 수도 있습니다.)이렇게 생각해 보니 10년 전에 처음 블로그를 시작했을 때가 생각납니다.원래 블로그를 시작하게 된 배경은 처음 사회생활에 시작할 때였습니다.나름 대학교 전공으로 프로그래밍에 자신 있다고 생각했으나, 현실 실무에서는 대학에서 배우던 방식으로 흘러가지 않고 어떻게 보면 비효율적으로 그러나 매우 생산적인 형태로 프로젝트를 한다고 느끼게 되었습니다.그래서 실무 프로그래밍이던가 실무적인 프로젝트 등을 공부하려고 했으나 그런 부분은 따로 정리해 둔 책도 없고 들을 수 있는 것은 선배의 조언뿐인 현실에서, 내가 블로그로 정리해 보면 어떨까 하는 생각으로 시작했던 것이 기억나네요.그와 더불어 업계의 선후배들과 가능하면 많은 교류 하면서 빠르게 배우고 의견을 주고받고 싶다라는 생각으로 시작했네요.그러나 블로그라는 게 시작하게 되면 아무래도 방문 접속자 수를 신경 안 쓸 수가 없어지고, 그러다 보니 빠른 속도로 포스트 내용을 업데이트하다 보니 강좌 같은 내용으로 포스트를 채워 버렸었습니다.저는 처음에는 원래 CS 개발자였습니다. 지금은 CS 개발보다는 웹개발 비중이 월등히 높지만, 저는 이 웹 프로그램을 블로그를 운영하면서 웹이라는 것을 알게 되었고 웹 프로그래밍을 공부하고 나중에는 검색 최적화, Http 규약 등 많은 것을 배우는 계기가 되었었습니다.지금 생각해보면 블로그를 통해 꼭 소통만이 아닌 개인적인 스킬 향상에도 많은 도움이 되었던 것 같습니다.그러나 예전 블로그의 현재 상태를 보니 한숨만 나올 정도로 엉망진창이 되었네요.이번에는 블로그를 다시 시작한 만큼 끝까지 해볼 생각입니다. 그 끝이 어디까지인가가 궁금합니다만..그리고 블로그의 타이틀처럼, 일지가 아닌 일기의 형식으로 개발하면서 느끼는 고충과 고민을 적어서 많은 사람과 공감이 되는 블로그를 만들어 보고 싶습니다.이번 블로그 플랫폼은 Github 플랫폼입니다. 예전에는 티스토리였으나 티스토리는 한국 내에서는 트래픽 속도가 빠른데 외국에서는 매우 느린 단점이 있습니다. 그에 반해 Github는 지역의 관계없이 매우 빠르죠.그러나 Github는 사실 웹호스팅의 플랫폼이 아닌 프로그램 소스 관리 저장소입니다. 그중 웹호스팅은 옵션으로 있습니다.그래서 Github는 다른 플랫폼과 다르게 디자인 테마를 제공하거나 데이터베이스를 제공하지 않습니다.지금 보는 현재 디자인도 순수로 전부 제작했습니다. 그래서 아직 부족한 부분이 많이 보이네요. 댓글 기능도 아직 개발 전입니다.이런 부족한 부분은 천천히 블로그를 운영해 가면서 채워나갈까 생각하고 있습니다.저의 개발 활동 무대는 일본입니다. 제가 한국보다는 일본이 더 좋아서 여기에서 생활하는 건 아니고 어쩌다 보니 여기까지 흘러온 것 같습니다.그러다 보니 보통사람과 조금 다른 경험도 많이 쌓이게 되었습니다.예를 들면 일본에서 생활을 하다 보니 차별 아닌 차별을 당한 경험도 있고, 일본에 있는 한국계 회사에 다니면서 느끼는 고충들..그리고 외국회사에 대한 문화 차이.. 생활하면서 느끼는 문화 차이 등등의 경험이 있습니다.그런 경험들을 통해 한국에서 일본에 진출하려는 분들, 또는 일본회사와 미국회사의 문화에 대해 궁금하신 분들.또 예전에 참 개발자에 대한 안 좋은 기사와 방송이 많아서 프로그램을 정말 좋아하는데 직업으로 망설이시는 분들.현업에 있으면서 앞으로 어떻게 해야 할까 하는 분들과 경험을 공유하면서 많은 소통을 하고 싶습니다.아직은 블로그에 적응이 되지 못해서 글이 어수선하고 두서가 없네요.. 원래 글재주가 뛰어난 편은 아니었지만 간만에 쓰다 보니 더 어수선합니다.어쨋든 앞으로 블로그를 어떻게 운영해 나갈지에 대해 또 많은 고민이 시작되겠지만 많은 방문과 응원부탁드립니다.</description><category>홈</category><author>nowonbun@gmail.com</author><guid>http://www.nowonbun.com/index.html</guid><pubDate>Mon, 12 Nov 2018 21:17:52 GMT</pubDate></item></channel></rss>