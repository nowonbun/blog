<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/" xmlns:activity="http://activitystrea.ms/spec/1.0/" ><channel><title>明月の開発ストーリ</title><link>https://www.nowonbun.com</link><description>Test</description><language>ja</language><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate><generator>nowonbun@gmail.com</generator><managingEditor>nowonbun@gmail.com</managingEditor><webMaster>nowonbun@gmail.com</webMaster><item><title>明月の開発ストーリ</title><link>https://www.nowonbun.com/index.html</link><description>明月の開発ストーリ</description><category>明月の開発ストーリ</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/index.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Devlopment note / C, C++, MFC</title><link>https://www.nowonbun.com/dev_clanguage.html</link><description>Devlopment note / C, C++, MFC</description><category>Devlopment note / C, C++, MFC</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_clanguage.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / C, C++, MFC</title><link>https://www.nowonbun.com/study_clanguage.html</link><description>Study / C, C++, MFC</description><category>Study / C, C++, MFC</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_clanguage.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Devlopment note / C#</title><link>https://www.nowonbun.com/dev_csharp.html</link><description>Devlopment note / C#</description><category>Devlopment note / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_csharp.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / C#</title><link>https://www.nowonbun.com/study_csharp.html</link><description>Study / C#</description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_csharp.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>[C# スタディ - 1] C#とは？</title><link>https://www.nowonbun.com/2.html</link><description><![CDATA[こんにちは。明月です。今日はc#を勉強する前にc#について説明します。プログラム言語はc、c++、java、c#など様々な言語があります。言語の誕生時期はc言語が一番早いし、次はmicrosoftからウィンドウ開発をしやすくするc++（mfc）、プログラムについて少しでも勉強したら聞いたかも知らない言語のjava、その次がこれから勉強しようと思うc#の順になります。誕生時期を見るとc#は上の4つの言語の中で最後になりますが、最後に誕生したから一番いい言語では思わられませんね。プログラム言語は各特徴があり、開発状況のたびに使う方法が違うと思います。各言語について簡単に説明するとc言語の場合はハードウェア系とos系(カーネル)、ドライバー系で主に使うし、c++(mfc)はグラフィック系またはc#で実装が大変な部分、c#よりメモリ管理が厳しい環境で使いますね。javaの場合はネットワークのウェブ系、アンドロイドモバイル系で使うし、c#はネットワークサーバクライアントウィンドウ（cs)系でよく使います。機能として使うところはそのとおりですが、プロジェクトの予算、環境などの影響でウィンドウプログラムをjavaで開発するし、c++とc#を混在して使う時もあります。c#は.net frameworkの上で動いています。.netframeworkはウィンドウosしかないのでlinuxやウィンドウ以外の環境では開発ができません。現在(2016年5月).netframeworkのバージョンは4.6まで発表してc#のバージョンは6.0まで発表しています。c#のバージョン別で説明すると下記のとおりになります。          c# バージョン    重要機能              c# 2.0               c# generics      anonymous method (匿名メソッド)      nullable type      partial type      c# yieldキーワード      delegateについてcovariance/contravariance                   c# 3.0               lambda expression (ラムダ)      anonymous type (匿名タイプ)      extension method ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/2.html</guid><pubDate>Wed, 3 Jul 2019 00:00:21 +0900</pubDate></item><item><title>[C# スタディ - 2] IDE(統合開発環境)のインストール</title><link>https://www.nowonbun.com/3.html</link><description><![CDATA[こんにちは。明月です。今日はc#開発環境を構築します。c#を開発するようにはmicrosoftのvisual studioが必要です。visual studioは昔には高いツールだったんでしたが、最近はcommunityバージョンで無料で提供しています。url - visual studio download現在(2019年7月)は上のurlで接続して下記の形のホームページが出ます。実際にホームページを見ると様々なダウンロードボタンがありますが我々は「community」バージョンをダウンロードして勉強します。さて、インストールファイルをダウンロードが完了し実行するとインストールが始まりますね。インストールが完了したらvisualstudioを実行してみましょう。始めに実行すると「初期のemailアドレスを入力して登録してください。」という意味のメッセージが出ます。既存にmicrosoftのホームページに接続してログインしたemailのアドレスを入力してemailから認証番号をもらいます。もし、登録してないならmicrosoftホームページに行って登録してください。(私の場合は既存に登録したので手続きは省略します。)認証番号登録が完了すると下記のとおりにメッセージが出て次の段階に超えます。最終に上の画面が出ますとインストールが成功です。ここまでc#の開発準備を完了しました。次の投稿ではc#のプログラム基本構造を勉強し、「helloworld」を出力しましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/3.html</guid><pubDate>Wed, 3 Jul 2019 00:00:32 +0900</pubDate></item><item><title>[C# スタディ - 3]  基本構造と「Hello world」</title><link>https://www.nowonbun.com/4.html</link><description><![CDATA[こんにちは。明月です。今日からc#の基本文法について勉強します。それならvisualstudioを起動して新しいプロジェクト(ctrl+shift+n)を生成しましょう。そうすれば下記とおりに画面が出ますね。テンプレート項目で「コンソールアプリケーション」というリストを選択します。その後で「名前」項目にプロジェクト名を書き込みます。(私の場合はhelloworldということに書き込みました。)そして「ok」ボタンを押下して新しいプロジェクトを生成します。新しいプロジェクトが開けると基本的なプログラムの構造は準備しています。次の投稿から具体的に勉強するので、今日は一旦「namespace」の中で「class」の中で「main」のメソッドにコードを書き込んで作業します。これから「helloworld」を出力しましょう。c#でコンソール関連クラスは「console」のクラスです。その中で出力するメソッドは「write」あるいは「writeline」のメソッドを利用します。その通りにコーディングをすると下記みたいになります。ソースコーディングが作成できたら「f5」キーを押下してデバックをしましょう。結果は予想とおりに得ました。ちなみにコーディングについて説明します。コーディング内容を見ると行の最後にセミコロン(;)があります。それはブロックを開閉表示(｛、｝)以外にソース命令語が終了する時にセミコロンをつけることでコーディング約束が決めています。初心者の場合はセミコロンの漏れでコンパイルエラーが発生する時があるのでご注意してください。また、上のソースを見ると最後に「console.writeline(“press any key…”); consolre.readlist();」の部分があります。その部分を消して実行(f5)するとあっというまで結果コンソールが開いて閉じます。それならソース実行結果を確認できないのでしばらくにはソースを組む時にその2行ソースを追加しましょう。ここまで「helloworld」を出力しましたが、考えよりプログラムが簡単に作成できましたよね。c#の利点は初心者も簡単にしやすくプログラムを作成できるし開発進入壁が低いことです。でもどんな言語でも開発が複雑になると言語の特徴を100％に活かせる必要がありますので勉強が必要です。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/4.html</guid><pubDate>Wed, 3 Jul 2019 00:00:53 +0900</pubDate></item><item><title>[C# スタディ - 4] コメント</title><link>https://www.nowonbun.com/5.html</link><description><![CDATA[こんにちは。明月です。前の投稿でプログラムの基本構造について勉強しました。そう見るとアセンブラーよりは読みやすいですが、人間が読みやすいには言えません。簡単なプログラムなら解読するのが大変ではないけど、複雑度が上がるとコードを読むのがだんだん大変になると思いますね。それでプログラムをコーディング式ではなく、人が読みやすい方法でコメントがあります。プログラム中でコメントを付ける方法は３つがあります。改行タイプのコメントです。使用方法は改行頭に「//」を付けて使います。次はブロックタイプのコメントがあります。使用方法は下記とおりです。ブロックタイプのコメントは重複処理ができないので、使用するときに注意が必要です。最後にxmlコメントがあります。xmlコメントはプロジェクトが終了する時にxmlコメントでマニュアルを生成できるコメントです。javaの場合はjavadocと同じコメントです。(でも実際にxmlコメントでマニュアルまで生成しません。機能としてはありますが…)使用方法はclass頭あるいはmethod頭で「///」を付けて使います。xmlコメントの場合各タグがあって、タグ別で説明する区切りがあります。下記の表を参考してください。          xmlコメントタグ    説明              summary    形式あるいは形式メンバ設定          remarks    詳細な説明          para    remarksの追加説明          value    プロパティの説明          example    使用例          list    リストとテーブル生成          code    何行目のコードで表示する時に使用          see    テキスト内部のリンク指定          seealso    参考部分に表せるテキスト指定          exception    例外説明          permision    接近権限説明          param    メソッドのパラメター説明          return    返却値を説明          c    説明中で含めているコード      プロジェクトを進める時に簡単なプログラムは一人で作成できますが、普通のプロジェクトならチームを組んで進めると思]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/5.html</guid><pubDate>Wed, 3 Jul 2019 00:01:13 +0900</pubDate></item><item><title>[C# スタディ - 5] データタイプとリテラル(literal)、 Nullable</title><link>https://www.nowonbun.com/6.html</link><description><![CDATA[こんにちは。明月です。今日はデータタイプとリテラル(literal)、nullableについて勉強します。とりあえず、データタイプについて説明します。我々がパソコンでプログラムを作ることは大きい計算機を作ることだと思うと良いです。利用の目的は差異があると思いますが、ゲーム、デザインツール、バッチプログラムなども内部を見ると結局に数の計算になっています。人間は整数、実数の区別せずに計算ができますが、パソコンの場合は整数、実数、文字が完全に分けてあります。それをデータタイプと命名してメモリを宣言する時に定義します。そうするとデータタイプ種類と説明に下記に記述します。          c#データタイプ    .netデータタイプ    説明              bool    system.boolean    true or false                      byte                system.byte                8ビットunsigned integer                                        sbyte                system.sbyte                8ビットsigned integer                                        short                system.int16                16ビットsigned integer                                        int                system.int32                32ビットsigned integer                                        long                system.int64                64ビットsigned integer                                        ushort                system.uint16                16ビットunsigned integer                ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/6.html</guid><pubDate>Thu, 4 Jul 2019 00:20:32 +0900</pubDate></item><item><title>[C# スタディ - 6] 変数と定数</title><link>https://www.nowonbun.com/7.html</link><description><![CDATA[こんにちは。明月です。今日は変数と定数、すなわちメモリにデータを格納する場所について勉強します。プログラムを作成して、様々な数を計算すると結果の値を何処か格納して保管する必要があります。そのため、プログラムを下記の形式で作成しなければならないです。上のことを見ると変数はメモリに格納する場所になることは分かりました。それならプログラムの設計によってデータが変わらないデータもある可能性がありますね。その時に変数宣言する仕方で「const」をつけると変わらない変数、すなわち定数になります。変数の場合は宣言する場所によって変数の使用方法が変わります。メンバ変数の場合はクラスが生成する時に生成されてクラスが解除する時に解除します。ローカルの場合はローカルブロックが閉じる時に解除します。この変数のcycleはクラスを勉強する時に詳しく勉強するので、今は使う仕方だけちゃんと覚えて行きましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/7.html</guid><pubDate>Thu, 4 Jul 2019 00:13:06 +0900</pubDate></item><item><title>[C# スタディ - 7] 配列とリスト(List)、 そしてArrayList</title><link>https://www.nowonbun.com/8.html</link><description><![CDATA[こんにちは。明月です。今日は配列について勉強します。我々がプログラムを作成すれば変数宣言をたくさんすると思います。例えば、１ヶ月のスケジュールのプログラムを作成すると思えば１ヶ月間のデータを格納する変数が必要だと思います。さらに考えると、１ヶ月ではなく１年分だと思うと365個の変数が必要です。そうするとソース管理が大変になると思います。それでその場合は同じタイプの変数を結んで配列に作ります。配列の仕様方法については下記のとおりになります。上の列例を見ると整数タイプの「int」系で「test」の変数に10個を宣言すると意味になります。配列は「0」番から始まって10個なので、「9」番までメモリに宣言されます。もし「10」番以上にデータを入れるとエラーになります。こんなみたいに配列を使う場合、何個を使うかを決めて宣言します。プログラム設計によって違うと思いますが、プログラムで変数を何個を使うか知らないケースもあります。その場合にできるほど、大きく配列を宣言するのはできないので、動的の配列、すなわちリストを使います。c#ではlistはクラス形態なので仕様方法は、下記とおりになります。配列を比べてリストは個数宣言が必要なく使います。でも今回は個数でけではなくデータタイプも知らないケースがあります。その場合はlist&amp;lt;object&amp;gt;を使っても良いですが、クラスとしてはarraylistがあります。今まで配列、リスト(list)、arraylistについて勉強しました。機能だけ見るとarraylistが使いやすいし、配列は厳しそうですね。それならarraylistだけ使えばいいと思いになりますが、配列とarraylistの差は利便性だけではなく、性能(パフォーマンス)も差があります。リスト、arraylistはクラスタイプなので構造体の配列より遅くなります。(配列リストの場合は再宣言、連携リストの場合は検索)データ処理量が少なければ何でも使っても構わないですが、大量のデータの場合はどんなタイプを使うかのことで実行速度の差が発生します。それで正確に使うのがプログラム品質のため良いと思います。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/8.html</guid><pubDate>Fri, 5 Jul 2019 00:14:08 +0900</pubDate></item><item><title>[C# スタディ - 8] 演算子</title><link>https://www.nowonbun.com/9.html</link><description><![CDATA[こんにちは。明月です。今日はプログラムの演算子について勉強します。プログラムは演算子が数学らしい数式の演算子があるし、その以外に論理演算子、条件演算子などもあります。演算子に関することは下記の表と例を参考して詳しく説明します。          演算子タイプ                演算子                                例                                   数式演算子                +, -, *, /, %                                int a = (x + y - z) * (b / c) % d;                                                        割当演算子                =, +=, -=, *=, /=, %=                int a = 100;sum += a;                                        増加/減少演算子                ++, --                int i = 1;i++;                                        論理演算子                &amp;amp;&amp;amp; (and), || (or), ! (not)                if ((a &amp;gt; 1 &amp;amp;&amp;amp; b &amp;lt; 0) || c == 1 || !d)                                        関係/比較演算子                &amp;lt;, &amp;gt;, ==, !=, &amp;gt;=, &amp;lt;=                if (a &amp;lt;= b)                                        ビット演算子                &amp;amp; (and), | (or), ^ (xor)                byte a=7;byte b=(a &amp;amp]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/9.html</guid><pubDate>Fri, 5 Jul 2019 00:13:41 +0900</pubDate></item><item><title>[C# スタディ - 9] 制御文 - 分岐 (if, switch〜case, goto)</title><link>https://www.nowonbun.com/10.html</link><description><![CDATA[こんにちは。明月です。今日からは制御文を勉強します。プログラムの制御文はc#だけではなく、c言語やjavaと同じです。そしてその中で制御文は大きく３つの形で分けます。プログラムの流れで何の項目を選んで流すかを決める分岐制御、特定ブロックの流れを繰り返すループ、ループの流れを分岐するループ分岐があります。その中で今日は分岐(if, switch〜case, goto)を勉強します。if〜else if〜else文if〜else if〜else文は真、偽によって処理する制御文です。上の例を説明すると変数「a」の値は「5」なので一つ目の分岐では「else if(a &amp;gt; 0)」を通って「console.writeline(&quot;文２&quot;);」になります。次の変数「b」の場合は「true」だから「if」の条件を満たします。それで「console.writeline(&quot;文４&quot;);」に実行されます。最後も「if」条件を満たすので「console.writeline(&quot;文６&quot;);」を実行します。switch文「switch」は制御条件値が間に合うところを処理するマルチ制御文です。上の例を見ると変数「a」は「5」の値が格納されています。それで「switch」の「case 5」を通って「console.writeline(&quot;文１&quot;);」を実行します。c#の「switch」文は他の言語と違うところがあります。それはc++、javaの場合は「switch〜case」に行って「break」を付けないことができます。「break」がなければ次の文に実行する処理になるがc#の場合はこの「case」の後に「break」が必須キーワードなので「break」を利用して次の段階に行く処理がありません。goto文「goto」文はラベルの部分に強制的に移動する制御文です。そして「goto」文はプログラムの中で使わない制御文です。なぜならプログラムの中で「goto」文が多いなら性能(パフォーマンス)が悪くなるし、後でソース管理が大変になるからです。参考してください。上の例を見ると実行中で「goto test」文にあうと「test」ラベルに移動ます。今日は制御文の分岐に関して勉強しました。その中で「if」の場合はプログラムで一番多く使う制御なのでよく覚えて行きまし]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/10.html</guid><pubDate>Sat, 6 Jul 2019 00:57:29 +0900</pubDate></item><item><title>[C# スタディ - 10] 制御文 - ループ(for, while, do〜while, foreach)</title><link>https://www.nowonbun.com/11.html</link><description><![CDATA[こんにちは。明月です。前の投稿で分岐に関して勉強しました。今日は引き続いて制御文のループに関して勉強します。ループは単語のいみとおりに繰り返す処理ということです。ループの種類は「for」、「while」、「do〜while」、「foreach」の４つがあります。for 文「for」文は初期化より終了条件が偽になるまで増減値を変換しながら繰り返す制御文です。例を見ると「i」の変数に「0」の値を初期して「i &amp;lt; 10」の条件をチェックします。結果が「真」になるので「console.writeline(i);」を実行します。文の処理が終わって増減式に行って「i」の値を増加(i = 1)します。また「i &amp;lt; 10」の条件をチェックしてまた「真」になるので「console.writelist(i);」を実行します。そのままに「i」の値が「10」になるまで繰り返します。while 文「while」文は条件式が真になる間に繰り返す制御文です。「while」文は「for」文の初期式と増減式が除いてるものです。上の例をみると「while」文には別に増減式がないので「i++」を除いたら無限ループ(ループが終わらない状態)になる可能性があるので気をつけてください。do〜while 文「do〜while」文は「while」と似ています。でも「while」は初めから条件式をチェックして繰り返しますが「do〜while」文は１回実行した後から条件式をチェックします。「do〜while」文は条件をチェックして文を実行することではなく文を実行してから条件を繰り返すかをチェックするものです。上の例を見るとwhileの場合は「i &amp;lt; 0」の条件に満たさないので「console.writeline(&quot;while&quot; + i);」が実行されなかったです。でも「do〜while」文の場合は「console.writeline(&quot;do while &quot; + i);」を１回に実行した後に条件文をチェックするので「do while 0」が出力されました。実際にプロジェクトする時に「do〜while」文は一般ループと流れが違うから判断がつかないことが多く発生します。それで「do〜while」文を使うのはお勧めしません。foreach 文配列またはリストの個数のほどに繰り返します]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/11.html</guid><pubDate>Sat, 6 Jul 2019 01:07:33 +0900</pubDate></item><item><title>[C# スタディ - 11] 制御文 - ループ分岐(break, continue)</title><link>https://www.nowonbun.com/12.html</link><description><![CDATA[こんにちは。明月です。今日は制御文の最後のループ分岐に関して勉強します。我々がプログラムロジックを作成すると無限ループを作る時があります。でも本当に無限になるとプログラムが終わらないのでループの中で止まること、すなわち分岐ループが必要です。break 文「break」はループ制御を抜け出す時に使う制御文です。上の式を見ると「while」文は条件式がいつも「真」(true)になるので無限ループになります。でも、文の中で「if」によって「i」が「10」になると「break」文を呼ばれて無限ループから抜け出します。ループを強制的に抜け出すのは「break」になります。でも抜け出すことではなく、ループ文を終わらせずに次のインデックスに行くケースもあります。contineu 文「continue」はループ制御の次のインデックスに飛び超える制御です。上の例を見ると別に「break」、「continue」を使わなくても「if」文だけで処理ができそうですね。でも「break」、「continue」をよく使うとソースが綺麗になるのでループの中には状態をよくみて使うほうが良いと思います。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/12.html</guid><pubDate>Sun, 7 Jul 2019 22:56:17 +0900</pubDate></item><item><title>[C# スタディ - 12] メソッド(関数)とvoid型</title><link>https://www.nowonbun.com/13.html</link><description><![CDATA[こんにちは。明月です。今日はc#のメソッドに関して勉強します。メソッドあるいは関数と呼ばれる機能は数学の関数(function)と同じ意味です。すなわち、関数に任意の数を入れると関数の式によって計算をされる数の値がでることになります。それなら、プログラムの関数の使用方法は下記のとおりです。上の例で「static」のキーワードはとりあえず無視しましょう。例を説明すると「exammethod」、「exammethod」の関数があります。「exammethod」の場合は「10」のデータを入れると「10」倍になって「100」の値が返却すると思います。「exammethod2」の場合は「10」、「20」のデータを入れると２つのデータが足すので「30」のデータが返却すると思いますね。メソッド(関数)は上の形態が基本ですが返却値が１つではなく２つ以上になるあるいはパラメタの個数が動的になる場合もあります。上の関数の場合はパラメタ「b」は「a」の値の商、「c」には「a」の値の余のデータが返却し、メソッド(関数)は余が「0」の場合は「true」、その以外は「false」を返却します。パラメタ個数が可変の場合は下記とおりです。上の例はパラメタで受け取ったデータをすべて合計する関数です。void今まで我々は関数の返却値があるように作成しました。でも逆に返却値が必要ではない場合もありますね。例えも上の返却値が２つ以上の例を見ると関数返却値は余が「0」かどうかの値を返却しました。でも、「0」かどうかの値は要らずに商と余だけ返却したい時があると思いますね。その場合は返却値に「void」のキーワードを書いて「返却をしない」というを明示します。今までメソッド(関数)の方法にかんして勉強しました。メソッド(関数)のことは数学のファンクションみたいに結果値に置換ができます。それなら数学の数列という数の並びがあります。たとえば「1」から「10」の合計はどうすればいうと数式に変換すると「1+2+3+4+5+6+7+8+9+10」になります。「10」の「1」を足すの等差数列を分析すると「9」の「1」を足すの等差数列+「10」に表現ができますね。すなわち「n」の「1」を足すの等差数列は(n-1)の「1」を足すの等差数列に表現ができます。そのとおりに「1」の等差数列は「1」になりますね。それをプログラムで実装すると下記とおりです。上の例を見ると「su]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/13.html</guid><pubDate>Sun, 7 Jul 2019 23:14:29 +0900</pubDate></item><item><title>[C# スタディ - 13] アクセス修飾子(public, private, protected)</title><link>https://www.nowonbun.com/14.html</link><description><![CDATA[こんにちは。明月です。今日はアクセス修飾子について勉強します。アクセス修飾子アクセス修飾子はoopの基本特性のカプセル化と関係があります。次の投稿のクラスについて勉強する時に詳しく説明すると思いますが、「c#」プログラミングはoop(オブジェクト指向プログラム)と呼びます。そしてoopの最小の単位のオブジェクトはクラスです。そしてクラスの中には様々なデータがあります。データを定義する時は見せても良いデータがありますが、隠さなければならないデータもあります。それを区別しながら作成する方をカプセル化と言います。そうすると、アクセス修飾子の種類は下記とおりです。          アクセス修飾子    内部クラス    外部クラス    派生クラス    プロジェクト              public    ○    ○    ○    ○          private    ○                      protected    ○        ○              internal    ○    ○    ○              protected internal    ○        ○          上の例は実際にそのように実装するとダメですが、アクセス修飾子の説明ために作成しました。とにかく、例を見ると「public」は変数「name」、「birth」、「year」、メソッド「setdata」が外部から見えます。逆に変数「year_birth」、「month_birth」、「day_birth」、メソッド「yearcalc」は「humen」クラスの構成より「year」を計算するためのデータなので外部から見せる必要がありません。逆に考えてすべての変数、メソッドが「public」になって外部に見せることになるとクラスの処理には問題がないですが、プロジェクト管理するためには深刻な問題が発生する可能性があります。なぜなら、ただ「name」、「birth」、「year」だけ見える時はクラスを知らない方が見てもユーザと関係があるクラスだと思いますが、すべてのデータが開けると意味がわからなくなります。また、上の例は簡単なので処理問題では発生しないけれども複雑のプログラムなら処理中で計算データを変更させると結果データが可笑しく出る可能性があることです。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/14.html</guid><pubDate>Mon, 8 Jul 2019 22:56:02 +0900</pubDate></item><item><title>[C# スタディ - 14] プロパティ(property)</title><link>https://www.nowonbun.com/15.html</link><description><![CDATA[こんにちは。明月です。今日はプロパティについて勉強します。前の投稿に「変数」について勉強しましたが、その中でメンバ変数が今日勉強するプロパティと関係があります。[c# スタディ - 6] 変数と定数oop(オブジェクト指向プログラム)の特徴でカプセルがあります。クラスを宣言して使う立場ではクラスの変数とメソッドを参照制限にすることをカプセルと言います。この制限はプログラム的で実装禁止ではありませんが、コーディングの規約(プログラム実装の方法として決められた約束)によって決められています。その規約の一つがクラスの「メンバ変数は「private」にする」、すなわち外部から参照禁止になっています。そうするとメンバ変数の値は外部で取得をどうするかといえばプロパティを通って取得します。上の例の「name」が基本的に使うプロパティの構造です。変数名が小文字で書いてるものをプロパティの変数名から語頭１桁を大文字に変換して書きます。「name」のデータは外部で直接に参照できなくて、「name」のプロパティを通って取得できます。読み専用プロパティの場合は「set」部分を省略して作成します。それで「comp」プロパティは「comp」変数からデータを取得できますが、格納ができない状況になっています。応用プロパティの場合は「string」タイプのデータを受け取ります。そして文字分け関数で文字列のデータを分けます。各「year」、「month」、「day」の変数に「int」型にて変換して格納します。また、逆に外部から取得する時は「year」、「month」、「day」データを合わせて「string」タイプに変換して返却しています。外部で見るとプロパティは「birth」タイプしか見えない構造になっています。実際にプログラム実装する時はほとんど基本プロパティ型を使います。それで「.net framework 3.0」からはメンバ変数も省略が可能な形式があります。今までプロパティについて勉強しました。でも、これだけではなぜプロパティを使うかを確かに認識ができません。プロパティの場合はただカプセルの理由だけではなく、継承、抽象等oopの特徴の部分と密接な関係があります。今はインタフェースや抽象クラスの概念がない状況では説明が難しいですね。とりあえず、上の形式で使い進んで、またインタフェース、抽象クラスチャプターで詳しく勉強しましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/15.html</guid><pubDate>Thu, 11 Jul 2019 23:22:56 +0900</pubDate></item><item><title>[C# スタディ - 15] クラス(class)とコンストラクタ、そしてnew(割り当て)</title><link>https://www.nowonbun.com/16.html</link><description><![CDATA[こんにちは。明月です。今日はクラスについて勉強します。プログラムを少しでも扱ったことがある方なら「クラス」について聞いたことがあると思います。クラス(class)クラスはoop(オブジェクト指向プログラム)の最小単位です。構成要素はメンバ変数、プロパティ、メソッド、イベントがあります。その中で我々は変数、プロパティ、メソッドについて勉強しました。イベントはデリゲートと関係がありまして少し後で勉強します。[c# スタディ - 6] 変数と定数[c# スタディ - 14] プロパティ(property)[c# スタディ - 12] メソッド(関数)とvoid型クラスの構成は上のとおりです。使用方法では「new」キーワードを使ってメモリに割り当て使います。new「new」キーワードは配列を宣言する時に使ったことがあります。配列を宣言する時と同様にクラスの「new」もメモリに「割り当てをします」という意味です。上の例を見ると割り当て演算子の区切りで「testclass test」「new testclass」に分けて考えて見ましょう。前の「testclass test」は変数と同様の意味でメモリアドレス(整数)が入ります。「new testclass」の場合はメモリ(heap)に「testclass」を割り当てます。上のイメージとおりにクラスが宣言し割り当てたと思われます。すなわち、「test」変数は「heap」に「testclass」が割り当てたメモリアドレスがあると意味です。そして割り当てた「testclass」のデータを取得することはコンマ「.」の区切りで取得できます。「test」変数名は「testclass」が割り当ててメモリアドレスが格納されたことは理解しました。そうすると「test」で割り当てたクラスの「data」変数にデータを格納して見ましょう。上のソースを見るとクラスの構造の中で「data」のプロパティがありますが、読み専用になっています。でも,「setdata」のメソッドを見ると「&quot;test&quot;」の文字列を合成して「data」に格納するところがあります。そうするとメソッドを通って「data」に「data」の値を格納します。(合成されて「testdata」になる。)そして「data」プロパティを通って「data」の値を出力して結果を確認しましょう。予想とおりに結果を得られました。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/16.html</guid><pubDate>Thu, 11 Jul 2019 23:21:18 +0900</pubDate></item><item><title>[C# スタディ - 16] static</title><link>https://www.nowonbun.com/17.html</link><description><![CDATA[こんにちは。明月です。今日は「static」について勉強します。「static」は俗に静的キーワードと言います。「static」の種類は「staticメソッド」、「static変数」、「staticクラス」があります。staticメソッド今まで勉強したとおりならメソッドを使うためにはクラスを割り当てなければならないです。なぜなら、oopの最小単位はクラスだし、メソッドはクラスの内部に存在しているからです。でもクラスとは関係なく、計算だけするメソッドが必要な時もあります。例えば、パラメタで「int」タイプデータを２つを受け取って、パラメタの数を足す計算だけするメソッドがあると思いましょう。そしてそのメソッドを使うためにクラスを割り当てる(new)ことはメモリが惜しい感じがしますね。その時に「static」メソッドに実装すればクラスを割り当てずにメソッドを使うことができます。上の例を見ると「new」(割り当て)をしなくてメソッドを使います。そうすれば、staticメソッドからクラス内部のメンバ変数を使えるかと疑問になりますね。上をみるとエラーが発生しますね。なぜなら「static」メソッドの場合はクラスを割り当てて使うものではなく静的領域なので、動的なクラスの部分に直接に参照ができないです。でも、メソッドの中でクラスを割り当てたら使えます。static変数static変数は消されない変数だといいます。すなわち、クラスの変数はクラスが割り当てる時に変数の値が生成してクラスが解除する時に変数の値が無くなります。でも、プロジェクトの中で唯一に宣言するし、解除が行わない変数も必要だと思いますね。その時に使う変数を「static」変数と言います。staticクラス「staticクラス」はクラスの構成メンバがすべて構成が「static」になります。そしてstaticクラスの場合はコンストラクタをもってられません。なぜなら、「staticクラス」は割り当て(new)られないので、コンストラクタが存在できません。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/17.html</guid><pubDate>Wed, 10 Jul 2019 00:20:54 +0900</pubDate></item><item><title>[C# スタディ - 17] struct(構造体)</title><link>https://www.nowonbun.com/18.html</link><description><![CDATA[こんにちは。明月です。今日はstruct(構造体)について勉強します。struct「struct」の意味的には「class(クラス)」と同じですね。すなわち、データを縛る最小単位です。そうするとなぜ「class」と「struct」にキーワードを分けただろうかと言えばメモリ参照方法の差があります。「class」の場合は外部でメモリに割り当ててメモリ参照タイプとして使いますが、「struct」の場合は宣言する時に「struct」内部でメモリに割り当てて値タイプとして使うの差があります。上の例をみるとクラスの場合は「aclass」を宣言して「new」キーワードで割り当てます。そして「aclass」の変数「data」に「10」の値を格納します。その後で「bclass」を宣言して「aclass」をメモリアドレスを代入します。その後で「bclass」の変数「data」に「15」の値を格納すると「aclass」の変数「data」の値はどうでしょうか？前のクラスの投稿にも説明しましたが、上の場合は「aclass」と「bclass」が同じクラスを参照しているので両方「15」の値を持っていることを知っています。[c# スタディ - 15] クラス(class)とコンストラクタ、そしてnew(割り当て)そうすると「astruct」と「bstruct」も同じパタンを考えれば両方の変数「data」が「15」になると思われますね。結果を見れば予想結果と違いますね。結果を見ると「aclass」と「bclass」は確かに同じメモリアドレスを入っていますが、「astruct」と「bstruct」の場合はメモリアドレスが違いますね。すなわち「teststruct bstruct」を宣言する時に内部でメモリに割り当てて後「bstruct」に「astruct」の値をコピーしたと意味になります。そしたらこれから「struct」の使用方法について勉強してみましょう。とりあえず、上の構造を見ると「struct」もコンストラクタがあります。構造体の場合もコンストラクタを呼び出すためには「new」キーワードを使います。その場合は内部からメモリが割り当てることではなく、クラスみたいに外部からメモリが割り当てます。また、継承について勉強する前ですが、構造体はstructから継承ができません。(それで、プロパティを使いません。)でも、インタフェースからは継承を]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/18.html</guid><pubDate>Thu, 11 Jul 2019 23:18:03 +0900</pubDate></item><item><title>[C# スタディ - 18] enum(列挙型)</title><link>https://www.nowonbun.com/19.html</link><description><![CDATA[こんにちは。明月です。今日はenum(列挙型)について勉強します。前の投稿で「const」、「static」を勉強したことがあります。そのことを合わせて定義変数を作られることを知っています。「enum」の場合は定義変数と似ている概念ですが、データの値より集計的な区別のため使うキーワードです。それで「enum」は値のとしての意味を持ってることよりプロセス制御のため使えるものです。enum改めていうと、enumは分岐の制御のために整数を集合的に定義するものです。上の例を見ると「enum」は分岐制御の区別のために定義しています。上の型が一般的に「enum」を使う方法ですね。でも「enum」にも実際の整数を与えて設定するの方法もあります。上の例を見ると「enum」のメンバに実際整数を格納して、プラグとして使っています。でも「enum」には上みたいに整数は格納できますが、実数、文字(列)は格納できません。上の例は初めの例とにていますね。でも、前は「switch」文で分岐しましたが、今回は列挙変数「weak」を直接に出力しました。２つ目の例とおりなら「０〜７」間の数字が出力すると予想になります。結果は予想と違いますね。結果を見ると「enum」のメンバ名ままで出力しました。それで前の例と今回の例と比較すれば列挙型の上をみるとアトリビュート「flags」が付けていることを確認できます。「flags」のアトリビュートは「tostring」で出力する時にアトリビュート「flags」がなければ整数値、アトリビュート「flags」が付けていると「enum」の変数名が出力します。列挙変数「process」に値が「5」になることは予想できます。でも、列挙型のアトリビュートに「flags」が付けているので、変数名を出力しようとしますが、列挙メンバに「5」の値を持っているメンバがありません。この場合はビット演算子で計算したとおりに「type」、「type3」が出力します。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/19.html</guid><pubDate>Wed, 10 Jul 2019 23:58:31 +0900</pubDate></item><item><title>[C# スタディ - 19]  継承とSealedクラス</title><link>https://www.nowonbun.com/20.html</link><description><![CDATA[こんにちは。明月です。今日は継承とsealedクラスについて勉強します。oopの特徴は抽象化、継承、多型、カプセル化があります。カプセルの場合はアクセス修飾子を勉強する時に説明したことがあります。[c# スタディ - 13] アクセス修飾子(public, private, protected)今日はoopの特徴の中の継承について勉強しましょう。継承この間にクラス、メソッド、プロパティ、変数の使用方法について勉強しました。正直にプログラムはその４つだけを知っても実装ができます。でも、プロジェクトが大きくなればなるほどその４つだけで実装が大変だし、出来上がった後を考えるとメンテおよびソース管理がすごく大変になると思います。その理由で継承は実装と管理のために使うと思っても結構です。継承の意味は親クラスから機能を引継いでもらい子クラスを生成することです。上の例をみると「successionbclass」を割り当てて「data1」のプロパティを呼び出します。でも「successionbclass」クラス内部には「data1」のプロパティがありません。しかし例の結果を見ると「successionbclass」に「data1」のデータが格納されるし、結果としても出力されます。なぜなら、「successionbclass」クラスは「successionaclass」クラスから機能をすべて継承したからのです。すなわち、「successionbclass」クラスは「successionaclass」クラスの機能をすべて使われると意味ですね。上の例を見ると「successionbclass」クラスの場合は「successionaclass」、「successioncclass」クラスと「successiondclass」クラスの場合は「successionbclass」を継承しています。もし、「successioncclass」のクラスと「successiondclass」のクラスが継承しなくてクラス内部で「data1」、「data2」を実装すると考えてみましょう。プロジェクト中で「data1」のデータタイプが「int」から「string」に修正することが発生すると継承しない場合は「successioncclass」のクラスと「successiondclass」のクラスを両方修正しなければならないのです。 しかし、継承してい]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/20.html</guid><pubDate>Thu, 11 Jul 2019 23:16:00 +0900</pubDate></item><item><title>[C# スタディ - 20] 抽象クラス、抽象メソッド、仮想メソッド</title><link>https://www.nowonbun.com/21.html</link><description><![CDATA[こんにちは。明月です。今日は抽象クラス、抽象メソッド、仮想メソッドについて勉強します。抽象クラス前の投稿で親クラスから継承すると親クラスの機能を引継いでもらって機能拡張をできることを勉強しました。でも、プロジェクトによって親クラス段階で仕様が決めておらず、派生クラス段階で仕様が決められる場合があります。例えば、各クラスの変数の初期値は違うけれど、変数、メソッドの構造が同様で作りたい場合があります。その時に親クラスからすべて一緒の変数、メソッドを作成して派生クラスからデータを取得するように作成します。その時に親クラスから取得メソッドの実装が決めておらず、派生クラス(子クラス)で実装させ、親クラスは派生クラスの実装させたことを呼び出すことです。すなわち、親クラスはそのメソッドを実装予約(抽象メソッド)して継承すれば実装することになっているクラスを抽象クラスといいます。抽象クラスと一般クラスの構造は同じですが、一般クラスは継承しなくてそのままクラスとして使えるけど抽象クラスの場合は継承しなくて使えません。抽象メソッド抽象メソッドの場合は必ず抽象クラス内だけ使えます。すなわち、抽象メソッドがあれば必ずクラスを抽象クラスに変換しなければならないという意味です。上の例を見ると「abstractclass」クラス内で抽象メソッド「getdate()」を宣言「abstract」しています。そのことを「childbclass」、「childcclass」クラスが継承して抽象メソッド「getdate()」を再実装「override」しています。そして親クラスのコンストラクタで派生メソッドを呼び出して変数「data」を設定しています。派生クラスの抽象メソッドを当該データから返却しています。結果を見ると各クラスの変数「data」の値を出力しています。そして結果は派生メソッドで返却したデータを「data」に格納して示させています。仮想メソッド抽象メソッドは親クラスで実装しておらず、派生クラスに実装を引継ぎます。でも、親クラスで全然実装しないことではなく、一部実装して派生クラス(子クラス)にも引き継いで再実装(override)する場合もあると思いますね。あるいは再実装しなく、親クラスのデフォルトに実装してメソッドを使われる時もあります。そのメソッドを仮想メソッドといいます。仮想メソッドは返却タイプ前に「virtual」とキーワード]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/21.html</guid><pubDate>Fri, 12 Jul 2019 00:18:43 +0900</pubDate></item><item><title>[C# スタディ - 21] this、base、ポリモーフィズム( overload (多型) )</title><link>https://www.nowonbun.com/22.html</link><description><![CDATA[こんにちは。明月です。今日は「this」、「base」、「ポリモーフィズム( overload (多型) )」について勉強します。前の投稿で継承について勉強したことがあります。継承のことを図で示せば下記とおりです。上の図を考えながら「this」、「base」を勉強しましょう。thisプログラムを作成すると多くの変数とメソッドを作ります。その度に変数名とメソッド名を命名するのは大変だと思います。それでクラスの中でメンバ変数あるいはメソッド(コンストラクタ)を同じ名で命名して同じ名の変数とメソッド(コンストラクタ)を「this」にキーワードで見分けして使います。上の例を見るとローカルパラメタの変数名を「data」に命名し、メンバの変数名も「data」に命名しました。 そうするとローカルメソッドの内で「data」名を使うと思えばメンバ変数を使いますかローカルを使いますか？答えは一番近い変数を使います。すなわち、「data」の変数はローカルパラメタの変数を参照していると言う意味です。改めていうと、「data」はローカルパラメタ「data」を指しているデータだし、「this.data」はメンバ変数の「data」を指しているデータです。大体的に「this」はメンバ変数か、ローカル変数かを見分けするために使いますが、コンストラクタで他のコンストラクタを呼び出す時も使います。上の例を見ると「main」メソッドの内で「testclass()」を割り当ててパラメタがないコンストラクタを呼び出します。コンストラクタの隣を見ると「this(0)」が付けて「int」のパラメタがあるコンストラクタを呼び出します。 また、パラメタが「int」型をコンストラクタは隣の「string」のパラメタがあるコンストラクタを呼び出します。纏めて順番に並べると「testclass(string s)」→「testclass(int i)」→「testclass()」の順で呼び出します。base「this」はクラスの自分自身を指すと思うと「base」の場合は親クラスを指しているキーワードです。上の例を見ると「base」、「this」の意味を確実に知ることになります。まず、コンストラクタの「base」は「this」の自分自身ではなく親クラスのコンストラクタを指していますね。また、メソッドの中で使った「base」も親クラスのメソッドを指しています。ポリモ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/22.html</guid><pubDate>Sat, 13 Jul 2019 00:57:04 +0900</pubDate></item><item><title>[C# スタディ - 22] インタフェース( interface )</title><link>https://www.nowonbun.com/23.html</link><description><![CDATA[こんにちは。明月です。今日はインタフェースについて勉強します。今まで継承すると思えばクラスあるいは抽象クラスから引継いてもらってクラスを生成することでした。でもその形なら２つ以上の継承をできずに統一されたデータタイプに結ぶことができないですね。各クラスは機能別で分けて処理するプロジェクトの案件がある場合、継承クラスをatype,btype,ctype,dtypeを作成して実装します。でも上の場合は一つずつ区分ができますが２つ以上に機能を結ぶのはできないですね。そのため、多重継承ができるものが必要でそれをインタフェース(interface)と言います。インタフェース(interface)インタフェース(interface)は抽象体なので実装しているロジックがあることではなく、抽象メソッドだけあります。上の例を見るとインタフェースを使われなくても、プログラム作成することができそうですね。ですから、インタフェースを使わなくても問題がなさそうだし、性能にも影響がなさそうですね。そのいうとおりでインタフェースを知らなくてもプログラムを作成できます。でもプロジェクトをデザイン、すなわちコーディング設計をする時にはインタフェースがなければ実装が大変になります。例えば、プロジェクトを構成する時にdbが２つがあると考えてみましょう。２つのデータベースで構成されているテーブル(データ構造)も全て違うことで、ユーザの場合は２つのデータを選ぶことではなく一つのデータベースから取得するみたいに構成して提供しましょうという課題があると考えましょう。上の例を見ると全体構造は少し複雑になりましたが、ロジックを使うユーザ(main関数)はデータベースを気にしずにデータだけ考えてロジックを実装ができます。また、上の条件ならデータベースが２つではなくもっと追加になってもソース修正が要らずにインタフェースに合わせてdblistに追加することができます。プロジェクトは一人で立ち上げることよりチームを組んで立ち上げる時が多いです。その時にモジュール実装するたびにモジュール間に機能影響があったり、エラーが発生するとプロジェクトを進めることが大変になると思います。それでoop開発はモジュールの結合分離することで勧めます。そのためにoopを実装するためにはインタフェースが必要なことです。プロジェクト構成方法、ソースを実装する方法には後でデザインパタンを勉]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/23.html</guid><pubDate>Sat, 13 Jul 2019 01:06:52 +0900</pubDate></item><item><title>[C# スタディ - 23] 例外処理(try〜catch,throwそしてfinally)</title><link>https://www.nowonbun.com/24.html</link><description><![CDATA[こんにちは。明月です。今日は例外処理について勉強します。例外処理はキーワード名をみればエラーを解決するキーワードみたいですが実はそうではありません。大きくみると全域の分岐というの意味が近いと思われます。この全域の分岐はエラー処理するところでよく使われるので例外処理と呼ばれるかも知れません。try〜catch、throw例外処理はプロセス処理順「try」ブロックの内で「exception」クラスタイプを「throw」から投げれば「catch」で受け取ります。上の例をみると「if」文と差がなさそうですね。でも「try〜catch,throw」は「try」ブロックの内で「throw」を発生することを「catch」で受け取るものなので「ｔｒｙ」のブロックのメソッド内で「throw」を投げても「catch」で受け取ります。そして継承関係でも「try〜catch、throw」ができます。すなわち親クラスで「exception」を「throw」で投げたら派生クラスの「try〜catch」で受け取ることができます。ここまで確認すると確かに一般分岐と差がありますね。一般分岐の場合は条件によって処理プロセスが変わりますが、「try〜catch、throw」の場合は「try」ブロックの内で「throw」を投げると「catch」にで受け取ることで処理になります。finally「try〜catch」の場合は処理中で投げる形態だから「throw」の次のレベルソースが実行しないです。そうことになると必ず実行すべきなソースレベルがある場合に論理的なエラーがなる可能性があります。上の例を見ると「method」で「exception」が発生すれば「i++」は実行しないので無限ループになります。(実は例みたいに極端的に実装しない。)それでエラーが発生(throw)しても無限ループにならないように「finally」キーワードを使います。「finally」の場合は「try」のブロックの内で返却「return」しても必ず処理するブロックです。なのでプログラムリソースを解除するところでよく使いますね。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/24.html</guid><pubDate>Mon, 15 Jul 2019 02:26:17 +0900</pubDate></item><item><title>[C# スタディ - 24] indexer(インデクサー)とyield(リファレンス)</title><link>https://www.nowonbun.com/25.html</link><description><![CDATA[こんにちは。明月です。今日はindexer(インデクサー)とyield(リファレンス)について勉強します。indexerとyieldの場合は他の言語にはない文法です。なので少し理解が大変だと思われることもできるが以外に簡単だしよく理解して利用すればプログラム品質があがることにもできると思います。indexer(インデクサー)indexerはクラスを配列みたいに宣言するように使用するキーワードです。上の例をみるとクラスを配列みたいに使っています。でも内部は本当の配列の構造になっていません。ただ、クラスを使用方法で配列みたいに宣言することで見やすくなることなので性能には影響がありません。yieldyieldの場合はデザインパタンの「interator」パタンと関係があるキーワードです。「interator」パタンは繰り返す的なデータ集団を一つずつに分離してデータを取り出しするパタンをいいます。普通のリストでデータを取り出す型は下記とおりです。上の例をみると外部で「listtest」クラスのメンバ変数「list」からデータを取得するようにはメンバ変数自体を返却するかインデックスを受け取って返却するかの一つです。初めの方法でメンバ変数「list」を返却することですが、そうすればoopの特性のカプセル化の意味がなくなります。実際に実装する形は２つ目ですが、インデックスを計算するようにリストの内部関数を連携して作成すべきです。(adapterパタン - リスト個数関数、リスト削除関数、リスト取得関数等)上の例を見るとリストを返却することではなく、ienumerableタイプを返却します。それでクラス内のリストと外部クラスで呼び出したリストのオブジェクトを分離しています。初めに説明したとおりにindexer,yieldは他の言語にはないキーワードです。(筆者が知ってる言語中では。)それで開発する間によく使うキーワードではないと思います。それでもよく認識して使えば可読性が上がると思うのでよく覚えていきましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/25.html</guid><pubDate>Tue, 16 Jul 2019 00:38:07 +0900</pubDate></item><item><title>[C# スタディ - 25] delegate(デリゲート)</title><link>https://www.nowonbun.com/26.html</link><description><![CDATA[こんにちは。明月です。今日はdelegate(デリゲート)について勉強しましょう。前に筆者がoop(オブジェクト指向プログラム)について説明したことがあります。oopの特徴はカプセル、継承、抽象、ポリモーフィズムによってクラス単位でデータを扱う方法です。そのことによってプログラムを設計する時に何のデータを受け取ってどんな処理するし、どんな結果あるいはデータを出力する流れを作成するのができます。oopの概念はオブジェクトの流れとしては定義していますが処理する方法には定義してないです。それで一から最後まで流れを決めてプログラミングするのでプログラムの性能が制限的になるし並列処理の実装が難しくなります。そのため、最近のプログラム言語のパラダイムは関数型のプログラムになりました。関数型のプログラムの理論は昔からありましたが、実装が難しい短所でよく使えませんでしだが、最近は関数型言語も誕生したし、方法でも前より発展してc#にも「.net framework3.0」が文法から並立処理、匿名メソッド、lamdaが追加されました。それで今日はc#の関数型のプログラムの初めの「delegate」について勉強します。「delegate」のキーワードは初期c#モデルからも使えますが、匿名メソッド、lamda式は「.net framework 3.0」から使用できます。delegate「delegate」は意味とおりに代理子です。すなわち、メソッドの抽象だと思えば理解しやすいと思いますが、メソッドを「delegate」を利用して一つのタイプに変換して呼び出す方法です。上の例を見ると「delegate」を通ってメソッドを呼び出します。「testmethod」「testmethod1」「testmethod2」は別のメソッドですが、呼び出すのはリストに結んで一括で呼び出せます。delegateフィールド「delegate」はメソッドを代理に呼び出すの意味は理解しました。デリゲートはメソッドを抽象(?)してメソッドを纏めって使う方法なのでいつもリストと一緒に使うはずです。「delegate」フィールドはそのデリゲートリスト代わりに「デリゲート」をリストらしく格納できられるものです。匿名メソッド今までメソッドはメソッドの型を実装した後呼び出して使うことで勉強しました。でもメソッドをデリゲートで使うことならメソッド名が必要ではない場合もあ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/26.html</guid><pubDate>Tue, 16 Jul 2019 00:48:40 +0900</pubDate></item><item><title>[C# スタディ - 26] event(イベント)</title><link>https://www.nowonbun.com/27.html</link><description><![CDATA[こんにちは。明月です。今日はevent(イベント)について勉強します。前の投稿で「delegate」はメソッドの動作を集まって呼び出せるものだと勉強しました。その中で「delegateフィールド」を通って「delegate」を格納あるいは呼び出すのができます。でも「delegateフィールド」は「public」で公開すると内部だけではなくクラスの外部でも呼び出すのができます。「delegate」はメソッドの代理子なので上のことに実装するのは悪いではないですが、そのことよりクラスの内部処理を外部に呼び出すのは怪しいじゃないかと思えられますね。すなわち、「delegate」フィールドはクラスの内部処理が内部と外部のメソッドに呼び出すことができる型になります。event(インベント)「event」の場合はクラスの外部で呼び出すのを防止しています。使用方法は既存の「delegate」フィールドの前に「event」キーワードを付けることで使えます。「delegatefield」と「event」の差を纏めると下記とおりです。	・delegateフィールドは使用演算子は(=,+=,-=)ですが、イベントは(+=,-=)だけです。	・delegateフィールドはクラス内部、外部すべて呼び出すのができますが、eventはクラス内部だけ呼び出せます。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/27.html</guid><pubDate>Tue, 16 Jul 2019 01:00:16 +0900</pubDate></item><item><title>[C# スタディ - 27] LINQ(リンク)-1</title><link>https://www.nowonbun.com/28.html</link><description><![CDATA[こんにちは。明月です。今日はc#ののlinqについて勉強します。プログラムを開発するとlist（リスト),map(dictionary)などをたくさん使うと思います。例えば仕様によって同じタイプのデータをリスト化にして実装するほうが実装が綺麗にできるし、ソース整理が楽だと思います。前の投稿でもlistについて勉強したことがあるので上の例を解析ができると思います。そうすれば上の「number」の「2」を検索するようにはどうしましょうか？一般的にはループで分岐文を付け入れて検索します。上の例はデータ複雑度が低いので簡単に実装ができますが、クラスのデータが複雑だし、量が多い場合は実装も大変になるし、データ処理時間も結構かかると思います。linqその場合があるとデータベースのクエリみたいに簡単に検索ができるのがあればいいと思われますね。それで「.net framework3.5」からリスト、ディクショナリをsqlクエリみたいなキーワードで簡単に検索ができるように「linq」ということを提供しています。上の例を見ると「getsearch2」のメソッドの中でsqlクエリみたいな「from」、「where」、「select」のキーワードがあります。結果は「getsearch」と同様に「number」を検索して「data」の値を返却します。そうすると「linq」のキーワードについて詳しく勉強しましょう。          linqキーワード    説明              from〜in    検索するリストあるいはディクショナリ、データテーブルを指定          where    リストを検索する条件          join    ２つ以上のデータリストを結合          orderby    結果のデータリストの整列          group    結果のデータリストのグループ化          select    結果データを抽出      linqの場合は上のキーワードを使ってリストを検索をします。そして検索した後のデータはただのリストを返却することではなく「ienumerable」タイプで返却しますね。 「ienumerable」は「yield」のキーワードを勉強する際に説明したことがあります。[c# スタディ - 24] indexer(インデクサー)とyield(リファレンス)も]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/28.html</guid><pubDate>Tue, 16 Jul 2019 20:42:22 +0900</pubDate></item><item><title>[C# スタディ - 28] LINQ(リンク)-2 (メソッド式)</title><link>https://www.nowonbun.com/29.html</link><description><![CDATA[こんにちは。明月です。前の投稿から続いてlinq(リンク)のメソッド式について勉強します。linq(リンク) - メソッド前の投稿にはlinqを「sqlquery」タイプで使いました。筆者もソースの可読性のため「sqlquery」タイプをお勧めしますが、仕様によって検索条件が複雑になると「sqlquery」だけですべての条件を実装できないと思います。そのためクエリタイプのlinqではなく、メソッドタイプの「linq」があって実装できます。whereメソッド上の例を見るとlist(リスト)で「where」メソッドを使っています。そのメソッド中でデリゲートの匿名メソッドを使って繰り返して返却値が「true」場合にデータを出すようになっています。すなわち、上の例は初めの「where」メソッドで「number」の値が5以上のデータかつ２つ目の「where」メソッドで「number」が８の以下のデータを返却してデータを出力します。orderメソッド上の例は「linq」の「orderby」の降順のメソッドです。where関数と同じみたいにメソッド中には匿名メソッドで処理して、返却値は順番対象の値を返却します。すなわち、「linqexampledata」の「number」の降順になって「9,8,7,6」になります。出力はデータの値を出力します。selectメソッド上の例の場合は「select」メソッドを利用して「linqexampledata」タイプから「string」タイプに変換していますね。joinメソッド上の例は２つのリストを組み合わせて結果を出力することです。様々の処理が入りましたが、「join」メソッドだけ見るとデリゲートが３つがあることが確認できます。初めのパラメタは組み合わせるリスト、２つ目は対象レコードで比較するデータ、３つ目は組み合わせるリストの比較するデータ、最後は組み合わせたデータを返却するデリゲートになっています。今までlinqの表現式をメソッドで作成する方法について勉強しました。ここで言うことで筆者はlinqメソッド形式と言いますが、実は「enumerable」の処理だと言うし「linq」メソッドはその「enumerable」の処理メソッドの中で１つのメソッドです。そうすると次の投稿は「enumerable」の他の式について調べてます。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/29.html</guid><pubDate>Tue, 16 Jul 2019 22:41:30 +0900</pubDate></item><item><title>[C# スタディ - 29] LINQ(リンク)-3 (Enumerableクラス)</title><link>https://www.nowonbun.com/30.html</link><description><![CDATA[こんにちは。明月です。今日はlinq(リンク)の「enumerable」について勉強します。「enumerable」は前の投稿で勉強したlinq(メソッド)も含めていることですが、コレクションのタイプのクラスなら(リスト、ディクショナリ、テーブル等)データを扱うように「enumerable」のクラスを拡張してメソッドを使えます。すなわち「enumerable」はデータを扱うクラスとして「where」、「orderby」、「select」の以外に「sum」、「average」、「max」、「min」、「aggregate」などのメソッドがあります。そうすると今日は「select」、「where」、「oderby」以外の「enumerable」クラスメソッドについて勉強しましょう。maxmaxのメソッドはコレクションタイプのクラスの中でデータの最大値を救うものです。このメソッドの返却値は整数、実数のみです。すなわち、文字、文字列、ブール代数(boolean)の値で返却をできないという意味です。上の例をみるとリストにtestclassのクラスを格納してmaxメソッドで最大値を検索しています。すなわち匿名メソッドでクラスのnumberデータを返却して結果はそのクラス達の最大値が出ると予想になります。minminのメソッドはコレクションタイプのクラスの中でデータの最少値を救うものです。このメソッドもmaxと同じとおりに整数、実数のみに返却します。sumsumのメソッドはコレクションタイプのクラスの中でデータの合計値を救うものです。このメソッドもmaxとminと同じとおりに整数、実数のみに返却します。averageaverageのメソッドはコレクションタイプのクラスの中でデータの平均値を救うものです。このメソッドもmaxとminとsuｍと同じとおりに整数、実数のみに返却します。ここまで数と関係がある「enumerable」のメソッドを調べてみました。次からはデータを扱って処理する「enumerable」クラスの「aggregate」と「zip」メソッドについて調べます。aggregateaggregateのメソッドはコレクションタイプのリストを繰り返してリストのデータを累積するものです。パラメタは累積しているデータと、新しく累積するデータを受け取ります。パラメタと返却値のデータタイプは対象のコレクションデータタイプと]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/30.html</guid><pubDate>Wed, 17 Jul 2019 20:58:37 +0900</pubDate></item><item><title>[C# スタディ - 30] Lamda(ラムダ)</title><link>https://www.nowonbun.com/31.html</link><description><![CDATA[こんにちは。明月です。今日はc#のlamdaについて勉強します。プログラムを開発した経験がある方なら最近にlamda(ラムダ)について聞いたことがあると思います。最近、トレンドになっている関数型プログラミングがこのラムダ式を利用して作成するからです。正確に言うとlamda式（ラムダ）は関数型プログラミングの匿名メソッド式を簡略に記述するような方法です。すなわち、匿名メソッドを簡略に記述する式がlamda式です。lamda下記の例は匿名メソッドを既存の方法のdelegateを利用して生成しました。[c# スタディ - 25] delegate(デリゲート)上の例は「delegate」の投稿で勉強したことがある例です。「delegate」キーワードで匿名メソッドを作成することではメンバーで宣言された「delegate」のデータタイプにパラメタデータタイプを合わせて作成します。戻り値もメンバーで宣言された「delegate」のデータタイプに合わせて返却します。次の例は「lamda」式で匿名メソッドを実装したことです。上の例をみると既存の「delegate」から「delegate」のキーワードが省略して、パラメタのデータタイプも省略しました。上の例を見ると「delegate」式の匿名メソッドを記述する文法より少し簡略になりました。しかし、上の例だけみるとlamda式で実装すればいい点が何かを知れないですね。それなら複雑に匿名メソッドで使う型の「enumerable」クラスのメソッドで例を確認してみると差が確実に見えそうです。[c# スタディ - 28] linq(リンク)-2 (メソッド式)次の例を「enumerable」クラスのメソッドの「join」です。joinメソッドのパラメタは匿名メソッドの３個があります。上の例を見ると２つのリストがあり、joinメソッドを通ってリストを併合します。「join」メソッドのパラメタは３つの匿名メソッドが必要です。それで始めのjoinメソッドには「delegate」の匿名メソッドを利用して実装しています。そして２つ目のjoinメソッドは「lamda」式を利用して実装していますね。性能は差が無いですが、ソースの可読性がたくさん上がることになります。（ソースが簡単になるとソース可読性が上がります。)最近のトレンドは関数型プログラミングですが、「delegate」メソッド式よりla]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/31.html</guid><pubDate>Thu, 18 Jul 2019 20:29:52 +0900</pubDate></item><item><title>[C# スタディ - 31] Partial Type(クラス分割)、拡張メソッド</title><link>https://www.nowonbun.com/32.html</link><description><![CDATA[こんにちは。明月です。今日はc#のpartial typeと拡張メソッドについて勉強します。プログラミングをしてみるとクラス内の処理が多くなってソース行目が長くなる場合があります。最近はide(visual studio)がすごくよいので、ソースが大きくてもメソッド検索やプロパティ検索が早めにできますが、それでもソースが大きいのはクラスサイズが大きくなって性能が遅くなる可能性がありますね。partial typeそれで、コンパイルする時には１つのクラスになりますが、ソースファイルを分けて作成できる文法の「partial type」があります。上の例を見ると「partialclass」のクラスを４つに分けて作成しました。でも、「partialclass」を割り当てて使う時には１つのクラスように使います。筆者はクラス分割(partial type)を使ったことがほとんどありません。そんなにソースを長く作成する前に抽象と継承を使ってソースを減らすか、クラスが大きくなると思うと、 クラス自体を分けて実装しますね。partial typeを使うくらいのクラスの大きさなら割り当てする時にクラスサイズが大きいので、遅くなりますね。 ソースの長さのために使うことではなく、機能として分けて管理することように実装すれば「partial type」を使用することも良いと思いますね。拡張メソッドこれからはクラス機能を追加する方法で拡張メソッドについて勉強します。クラスの機能を追加する方法ではクラスを継承してメソッドを追加する方法があります。クラスにメソッドを拡張する時にはクラスを継承する方法が正確です。でも機能を１つだけ追加するように派生クラスを作る場合、または「sealed」になったクラス(継承できないクラス)に機能を追加する場合には継承する方法でできませんね。そのため、c#は継承しなくてもメソッドを追加する方法で拡張メソッドを提供しています。[c# スタディ - 19] 継承とsealedクラス上の例を見ると「parentclass」クラス内では「print2」メソッドがありません。でも「main」で割り当てて使う方法をみるとメソッド「print2」があるように使っています。「print2」メソッドは「parentclass」のクラスの内ではなく、「program」クラスの中で「parentclass」のメソッド拡張されて「]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/32.html</guid><pubDate>Thu, 18 Jul 2019 22:56:18 +0900</pubDate></item><item><title>[C# スタディ - 32] Objectタイプ、varタイプ(匿名タイプ)、dynamicタイプ</title><link>https://www.nowonbun.com/33.html</link><description><![CDATA[こんにちは。明月です。今日は高級データタイプ文法のobjectタイプ、varタイプ(匿名タイプ)、dynamicタイプについて勉強します。筆者はc#の勉強の初め部分でデータタイプについて勉強したことがあります。[c# スタディ - 5] データタイプとリテラル(literal)、 nullable[c# スタディ - 6] 変数と定数すなわち、データを宣言して使うことあるいはクラスを割当して使う方法は「データタイプ　変数名 = new クラス名()」の形で使いました。上の例を見るとデータタイプに「testclass1」を宣言してクラスを割り当てて使います。ここまでは今まで勉強したとおりに問題がありません。objectタイプそれでは、c#のことではすべてのデータタイプとクラスの最高の親クラスが存在します。それを「object」タイプで基本のメソッドは「tostring」等を持っているクラスです。それですべてのクラス、データタイプは「tostring」を持っていることです。そうすると次は「object」タイプの例です。でもデータタイプを「object」で宣言して「testclass1」を割り当てれば、データタイプが一番上位の抽象クラスを宣言したことなので、「testclass1」タイプままで使われずに、「object」のタイプに使われるので「testclass1」の属性を使うことができないですね。それで「testclass1」属性を使うためには「testclass1」クラスに強制キャスティングしてから使うことができます。しかし、強制キャスティングの問題はコンパイルする前の状況でエラーを発見しにくいし、ソース可読性も落ちる問題が発生します。匿名タイプ(var)それでデータタイプを正義しなくて使えるタイプがあります。「object」タイプほどにデータタイプのとしての役割はありませんが、割り当てる時にデータタイプを明示しなくて使うことができる匿名タイプがあります。でも、匿名タイプは見た目は「object」タイプと似ていることでみえますが、コンパイル段階でクラスを割り当てる時にデータタイプが決めることなので他のタイプに再割当てはできません。すなわち、匿名タイプはソース段階の見た目を整理することだけなので性能にも影響がありません。dynamic匿名クラスの再割当てる問題を解決するようなタイプが「dynamic」タイプで]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/33.html</guid><pubDate>Thu, 18 Jul 2019 22:52:02 +0900</pubDate></item><item><title>[C# スタディ - 33] Reflection(リフレクション)</title><link>https://www.nowonbun.com/34.html</link><description><![CDATA[こんにちは。明月です。今日は「reflection(リフレクション)」について勉強します。reflection(リフレクション)の機能はc#だけにある機能ではなく、c言語の以降のプログラム言語なら全部支援している機能だと思います。そのほど、プログラミングの中で重要な部分だし、動的なプログラムを実装するところになくてならない部分だと思います。reflection(リフレクション)今まで我々はクラスを割り当てるし、変数を宣言するし、メソッドを呼び出すことでプログラムを実装しました。reflectionはそのプログラムの流れを静的で実装する(ソースの中でメソッド名を呼び出す)ことではなく動的に実装する(ソースの中で呼び出すメソッドが決まってない)ための機能です。すなわち、任意なクラスのメソッドを呼び出すためにはソースの中でメソッド名を実装して使うとおもいますが、reflectionの場合はそのメソッド名によってメソッドオブジェクトを取得してinvokeメソッド(実行)を通って実装することと思います。上のソースを見ると普通のクラスを割り当ててメソッドを呼び出す方法です。でも次の例はreflectionを利用して静的に実装した部分を動的に実装することです。上の例はメソッドをreflection（リフレクション)タイプで動的にメソッドを呼び出したソースです。ソースを見るとクラスは「activator.createinstance」のメソッドを通ってクラスをインスタンス化(割り当て)します。そしてインスタンス化されたオブジェクトから「getmethod」メソッドを通ってメソッドのオブジェクトを取得してinvoke(実行)することでリフレクションタイプを実装したものです。上の例だけみるとなぜreflectionタイプに実装するかを分かりません。上の例を見ると「print1」、「print2」、「print3」、「print4」、「print5」を呼び出すメソッド「program.print」で呼び出すメソッドを決めることではなくて「program.print」メソッドを呼ばせる外部からメソッド種類を決める形になっています。 すなわち、プログラムのメソッドを呼び出す仕方で実装する時に決めることではなく、外部入力ことでメソッド処理を制御ができる意味になります。そうするとreflection(リフレクション)の種類について調べ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/34.html</guid><pubDate>Sat, 20 Jul 2019 02:22:35 +0900</pubDate></item><item><title>[C# スタディ - 34] Attribute(アトリビュート)</title><link>https://www.nowonbun.com/35.html</link><description><![CDATA[こんにちは。明月です。今日は(attribute)アトリビュートについて勉強します。c#のattribute(アトリビュート)はjavaのアノテーションと同じ意味のキーワードです。クラスあるいはメソッドを実装する場合に必要な情報と特性を定義することの意味です。そうすればc#から基本的に提供するattribute(アトリビュート)とユーザーが作成して使う仕方について勉強してみましょう。attribute(アトリビュート)          attribute    説明              clscompliant    アセンブリのすべての型をclsに合わせて使用          obsolete    使用しないと要素を表す。          conditional    全処理機を識別子によって実行する可否を決定          dllimport    非管理コードの形態で実行するメソッドを表す。          dispid    comのdispatchのidを表す。          serializable    クラスあるいは構造体がシリアルライズにするのを表す。          transaction    トランザクションを無視になるか支援できるかを表す。      筆者も上の表の中で「dllimport」、「serializable」、「transaction」を使ったことがありあます。「dllimport」の場合は「c」と「c++」あるいは「win　com+」のdllライブラリファイルをc#にインポートするようにするアトリビュートです。上の例は「dllimport」のアトリビュートでcom+ dllライブラリを参照して使うものです。「writeprivateprofilestring」と「getprivateprofilestring」の場合は「c++」、「mfc」で開発したことがある方ならしてると思いますが、「ini」環境ファイルを読み込むまたは書き込むような関数です。windowの中で組込のメソッドですね。「messagebox」の場合も旧windowのメッセージの組込のメソッドです。ここまで、c#から提供するアトリビュートを使う方法を勉強しました。表としてはたくさんありますが、筆者も使ったことがないし、実際に「dllimport」以外のアトリビュートは使わない]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/35.html</guid><pubDate>Sat, 20 Jul 2019 02:28:06 +0900</pubDate></item><item><title>[C# スタディ - 35] MSDN(Microsoft Developer Network)</title><link>https://www.nowonbun.com/36.html</link><description><![CDATA[こんにちは。明月です。ここまで「c#」の基本的な文法については大体に勉強したと思います。これからは「c#.net framework」から提供する「class」について勉強するかと思いますが、実は「c#.net framework」から提供する「class」はすごく多いので全部できるか疑問がなりますね。（笑)それで、「c#.net framework」のクラスについて勉強する前に「class」を使う方法について調べてみようかと思います。「.net framework」には「class」を全て勉強しなくても、「class」の構成について説明しているマニュアルがあります。我々はそれを「msdn(microsoft developer network)」と言います。得にms関連プログラマ達にはプログラムバイブルとも呼ばれます。msdn「.net frameworkのmsdn」のアドレスは下記とおりです。リンク - msdnmsdnに接続してみると様々なコンテンツがありますが、我々はプログラムの関連クラスドキュメントが必要なので「ドキュメント」項目に行きます。クラスの見る仕方を勉強するため、「string」クラスを例で「string」のドキュメントを参照してみましょう。リンク - [msdn]string クラス上のアドレスで接続すると「string」のドキュメントに移動します。「string」クラスのドキュメントを見ると「コンストラクタ」、「フィールド」、「メソッド」、「イベント」のことで区分して分けてなります。※「string」は「イベント」がないので、実際に「msdn」のドキュメントを見ると「イベント」項目がありません。でもイベントがあるクラスを見ると「イベント」項目があるので参考してください。ドキュメントを全般的に見ると我々が勉強したとおりにクラス基本構造で説明しています。すなわち、ユーザが「string」オブジェクトを使うようにアクセス修飾子が「public」段階のオブジェクトについて何のメソッドを使うとどの結果が出るかについて説明しています。そうすると、msdnを参照して「string」のクラスを使って見ましょう。ドキュメントで「string」機能を見ると「tolower()」、「toupeer()」のメソッドがあります。上のドキュメントを見ると「tolower()」は小文字に変換するメソッド、「to]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/36.html</guid><pubDate>Mon, 22 Jul 2019 23:16:46 +0900</pubDate></item><item><title>[C# スタディ - 36] ファイルシステム(File System) - FileInfo,DirectoryInfo</title><link>https://www.nowonbun.com/37.html</link><description><![CDATA[こんにちは。明月です。今日から「c#」の文法ではなく「c#.netframework」でよく使うクラス、システムについて勉強します。c#でプロジェクトを構築して実装する時によく使うクラスとネームスペースがあります。 それはファイルを扱うもののファイルシステム、通信する時に使うソケットシステム、データを構造的に構成するxmlシステム,jsonシステム等で「c#.netframework」から様々なモジュールシステムを提供しています。その中で今日からはファイルを扱うクラスについて勉強します。ファイルシステムは基本的にファイルとディレクトリを扱うクラ組です。体表的にファイルを扱うクラスは「fileinfo」とディレクトリを扱うクラスは「directoryinfo」があります。fileinfo下記のアドレスリンクは「fileinfo」のクラスの説明です。接続して確認をしてください。msdnリンク - fileinfo クラスfileinfoのクラスはファイルを扱うクラスです。ファイルのコピー、削除、移動、プロパティ情報を閲覧する場合に「fileinfo」クラスを利用して実装します。上の例を見ると「test.txt」を読み込んで生成日付を出力しています。そしてファイルをコピーしてまた生成日付を取得して最終には削除する流れで実装されています。結果を見ると「test2.txt」のファイルは生成してすぐ削除する流れなので、「work」のディレクトリの中には「test.txt」ファイルが見えないですね。directoryinfo下記のアドレスリンクは「directoryinfo」のクラスの説明です。接続して確認をしてください。msdnリンク - directoryinfo クラスdirectoryinfoのクラスはディレクトリを扱うクラスです。ディレクトリのコピー、削除、移動、プロパティ情報を閲覧する場合に「directoryinfo」クラスを利用して実装されています。上の例は「work」ディレクトリの生成日付を取得して出力していますね。後で「work」のディレクトリの中でファイルを取得して「fileinfo」のクラスに返却していますね。そして下記ディレクトリの「create1」、「create2」を生成して「create2」のディレクトリは削除します。結果としては「create2」ディレクトリを削除したので「create]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/37.html</guid><pubDate>Mon, 22 Jul 2019 23:31:20 +0900</pubDate></item><item><title>[C# スタディ - 37] ファイルシステム(File System) - FileStream、 Encoding、 Serializable</title><link>https://www.nowonbun.com/38.html</link><description><![CDATA[こんにちは。明月です。前の投稿でファイルとディレクトリを扱う方法について勉強しました。今日はファイルを作成する方法について勉強します。パソコンの中でファイルの種類は様々なことがあります。その中でドキュメントタイプだけで考えてもエクセル、ワード、テキスト、csv等の様々な種類があります。でもドキュメントタイプか、イメージ、様々なデータでもファイルは基本的にバイナリデータでされています。バイナリデータということをプログラム的に考えると「byte」タイプにされていることの意味です。filestreamc#にはその「byte」型にされているファイルを書き込むあるいは読み込むクラスがあり、それをc#では「filestream」というクラスがバイナリを扱うことです。そうすると「filestream」についてmsdnから調べ、使用方法について勉強します。msdnリンク - filestream クラスfilestreamはmsdnをみると「ファイルについてストリーム(stream)を提供します」ということで書いています。そうすると、streamについて知らないので、まずfilestreamを勉強する前にstreamについて勉強します。「stream」というのはファイルだけではなく通信と様々なデータを扱う時にstream(ストリーム)を使います。我々がテキストを開いて文字を書いて格納するものまたは格納したファイルを開いて格納したデータを画面に確認するものだと思います。改めていうとデータを格納して格納したとおりに画面に見えることが当たり前だと思いますがパソコンの中では当たり前ではないですね。テキストに「あいうえお」と書くとファイルが小さいからそのままで格納することができると思いますが、ファイルサイズが「100mb」「1gb」だとそのくらいの空間がハードディスクにない可能性もあります。そして上の状況になるとデータを「20mb」「50mb」で分けてデータをハードディスクに格納します。でもユーザーが「file」を作成する時あるいは閲覧する時にファイルが分散されているものを探して合せることやファイルを作成する時にディスクをの空間を計算して分割するんだと思えばファイルシステムを実装することが結構難しくなると思われます。それで「stream」では格納する時に一連のデータを受け取ってディスクの状況に合わせてファイルを作成することやファイ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/38.html</guid><pubDate>Mon, 22 Jul 2019 23:46:07 +0900</pubDate></item><item><title>[C# スタディ - 38] 「IDisposable」と「using」</title><link>https://www.nowonbun.com/39.html</link><description><![CDATA[こんにちは。明月です。前の投稿までfileシステムについて勉強しました。少し勉強順番が悪くなりましたが、今日は「c#」の文法の「using」と「idisposable」のインターフェースについて勉強します。idisposable「idisposable」のインターフェースは「dispose」のメソッドを抽象してコネクションと関係あるクラスに継承して「ｄｉｓｐｏｓｅ」（解除）メソッドを実装させるようことです。すなわち、filestreamと通信、データベース連携等のクラスレベルでリソースを解除するためにdisposeメソッドを実装することです。msdnリンク - idisposable インターフェイス上の例は「dispose」メソッドでリソースを解除しなく、他のストリームで同じリソースのコネクションを取得するようにしてエラーを発生することを実装したことです。すなわち、データを作成するリソースのコネクションを取得してリソースを解除しない状況で読み込むためにコネクションを取得するように実装したのでエラーが発生したことです。リソースを取得~解除の規則はc#だけではなく全てのプログラム言語にも同じ規則です。それでリソースを取得する時には必ず解除しますという構造をちゃんと認識するべきです。今まで勉強したとおりに簡単なプログラムな作成する時にはリソース取得、解除がそんなに難しくないです。しかし大きいプログラムからはリソース返却するロジックはそんなに簡単ではありません。using「using」はソースの一番上端で「namespace」を宣言する時に使うキーワードです。でも、「.netframewor3.5」から「idisposable」インターフェースを継承しているクラスに囲まれていれば処理が終わる時期に「dispose」メソッドを呼び出す機能もあります。上のコンストラクタをみると最後にtextwriterタイプのオブジェクトは「dispose」のメソッドを呼び出して解除しましたが、中のfilestream、bufferedstreamのストリームは解除することが大変になっています。今まで「idisposable」と「using」の関係について勉強しました。「using」と「idisposable」はjavaの「try」と「iclosable」の関係と同じですね。「using」〜「idisposable」はプログラムの]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/39.html</guid><pubDate>Tue, 23 Jul 2019 00:06:15 +0900</pubDate></item><item><title>[C# スタディ - 39] Thread(スレッド)</title><link>https://www.nowonbun.com/40.html</link><description><![CDATA[こんにちは。明月です。今日は「thread」(スレッド)に関して勉強します。thread(スレッド)プログラムを扱ってある方なら、特にアプリの関して開発したことがある方ならスレッドについて一回以上に聞いたことがあると思います。スレッドを定義するとプログラムを実行する最小の単位として一つのプロセス(プログラム)の中で一つ以上のスレッドを動かすことができまして並列処理をするように作成する要素だと思います。msdnリンク - thread(スレッド)説明が難しいですが、例を通って続きます。上の例を見ると我々は「threadex(“test1”)」、「threadex(“test2”)」、「threadex(“test3”)」の順に実行することはよく知っています。でも、プログラムを作成する時にパフォーマンスとためにあるいは他の理由のために、上のメソッドを同時に実行する時があります。上のソースを参照して結果を見ると「threadex(“test1”)」、「threadex(“test2”)」、「threadex(“test3”)」を順で呼び出しましたが、処理は順番通りではなく、同時に処理にするみたいにみえること、すなわち、並列に処理することで見えます。スレッドを呼ばれた後に「startwatchthread」を関数を呼ばれる部分があります。スレッド処理の中では「program」のコンストラクタも一つのスレッドになるため、「threadex(“test1”)」、「threadex(“test2”)」、「threadex(“test3”)」をスレッド並列処理をすると各関数が終わる前に「program」のコンストラクタが終わってしまう現象になるはずです。そのため、「startwatchthread」の関数は各スレッドが終わる時まで待つ処理、すなわち、メインスレッドがサブスレッドを待つ処理、改めていうと同期化処理を実装しています。これからスレッドを使うことでプログラムのパフォーマンスがどのくらいに改善することができるかを確認しましょう。上のソースを見るとスレッドを使わない処理時間(始めの例)とスレッドを使った処理時間(二つ目の例)を比較してみると約3倍に早くなることの結果が出ます。スレッドを使うと必ずパフォーマンス改善になって処理速度がアップすることではないけれども、上の例はioみたいに処理パフォーマンスと関係がある要素は]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/40.html</guid><pubDate>Wed, 24 Jul 2019 00:58:34 +0900</pubDate></item><item><title>Devlopment note / Java</title><link>https://www.nowonbun.com/dev_java.html</link><description>Devlopment note / Java</description><category>Devlopment note / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_java.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / Java</title><link>https://www.nowonbun.com/study_java.html</link><description>Study / Java</description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_java.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>[Java スタディ - 1] Javaとは？、Javaインストール、Eclipseインストール</title><link>https://www.nowonbun.com/41.html</link><description><![CDATA[こんにちは。明月です。今日まで「c#」について勉強しましたが、今日から「java」についても勉強しようかと思います。「c#」と「java」の場合は互いに似ている言語だし、文法も似ているので、事前に一緒に「c#」を勉強した方は「java」も簡単に習得できる言語ではないかと思いになります。とりあえず、「java」について調べてみます。javaについて「java」は1991年代にジェームズ・ゴスリンとその人のチームによって開発されて1995年に発表しました。初めは家電製品等のため開発されましたが、現在はウェブアプリケーションで一番人気があるプログラム言語になりました。現在、「java」はサン・マイクロシステムズによって無料で提供しているし、「java」のバージョンは12.0まで発表しました。「java」の場合は「c#」を比べて値段が安いですが、安いって言うのは「c#」がお金がかかることではなく、javaの環境を作るように立ち上がるシステムが無料オープンソースが多いですね。例えば、サーバの場合はcentosがあるしideツールでも「eclipse」、「netbeans」があるます。そしてウェブサーバ、アプリサーバの「apache」、「tomcat」、「glassfish」、「jboss」がすべて無料なので、システムを立ち上げる時、比較的に安く構築ができますね。そうすろとこれからjavaを開発するようにjavaのインストールとeclipseをインストールします。最近のwindows環境だと基本的にjavaがインストールされていますが、最新バージョンをダウンロードします。(参考：javaのバージョンはoracleバージョンとopenjavaバージョンがありますが、oracleの場合は最近著作権の問題で一応無料ですが、念のためopenjavaでインストールします。)javaインストールリンク - https://jdk.java.net/12/上のリンクを接続してopenjdk12をダウンロードします。ホームページ見るともう32ビットとプログラムを存在もしないですね。32ビットを利用したいなら、仕方がなくてoracle jskを使うしかないですね。ダウンロードが完了すれば適当なところで圧縮を解凍します。私の場合はd:\javaに解凍しました。javaをインストールしましたら、これからはpathを設定します。そしてシステ]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/41.html</guid><pubDate>Wed, 24 Jul 2019 23:19:15 +0900</pubDate></item><item><title>[Java スタディ - 2] 変数と定数</title><link>https://www.nowonbun.com/42.html</link><description><![CDATA[こんにちは。明月です。変数と定数に関してはすべてのlanguageと差異が多くないです。それでjavaだって別に他のlanguageと違うことではありません。プログラムは小さい単位でみれば一つの計算機と同じです。単純に値を加算するし、減算、乗算、除算の計算式ですね。それでプログラムで計算する時には数学の方程式だとおもったらよいです。例えば、x+y=zの式があり、ユーザからxの値は1yの値は2で入力されたら結果はzは3になりますという計算式ですね。ここで我々が考えられることなら「+」、「=」は演算子で、「x」、「y」、「z」は変数になります。それを変数の値をメモリに格納して計算することです。上の例はeclipseでjavaプログラムを初めに生成する時の構造になります。基本的にpublic static void mainをクラスの中で探して実行することになります。上の例を見ると「int z = x + y」があります。基本的に数学では「x + y = z」の形式ですがプログラムはイコールが前にあります。その文法で計算すると「z」の値は「x」の「1」と「y」の「2」が加算して「3」になります。結果は出力関数の「system.out.println」を利用して出力します。定数に関して説明します。プログラム上の形は差異がたくさんあることではなく、ただデータを変更できるかできないかの差だけです。定数の場合は変数宣言したところの前にfinalのキーワードを入れて後から変更ができないようにすることです。この定数のデータは実務でマスターデータとして変更ないデータで職別データのため、またクラスの概念だと割り当てを固定にすることになります。上の例で私が「f」の定数を宣言して「x + y + z」の値をまた入れようとしましたが、eclipse側でソースレベルでエラーが発生しました。この変数と定数はプログラムを作成する時、すごくよく使う概念です。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/42.html</guid><pubDate>Wed, 24 Jul 2019 23:13:54 +0900</pubDate></item><item><title>[Java スタディ - 3] データタイプ</title><link>https://www.nowonbun.com/43.html</link><description><![CDATA[こんにちは。明月です。私の考えでプログラムでデータタイプは一番重要なものではないかと思います。すべての変数にはこのデータタイプがあるし、変数でデータタイプを設定することでクラスのメモリサイズ、プログラムの性能と関係があることからです。データタイプはjavaだって他のlanguageと比べて特別に差異があることではなく、c++とc#とほとンと似てることになります。データタイプの種類は下記通りになります。                    キーワード        説明                            文字形式データタイプ      	  	    char		16ビットユニコードの文字(asciiコード参照)	  	  	    string		char形式になっている湯にコード文字列	  	          bool形式(正、不)データタイプ      	  	    boolean		正(true)、不(false)形式の論理データ	  	          整数形式データタイプ      	  	    byte		-128~127の範囲のデータ	  	  	    short		-32,768~32,767の範囲のデータ	  	  	    int		-2,147,483,648~2,147,483,647の範囲のデータ	  	  	    long		-9,233,372,036,854,755,808~9,223,372,036,854,755,807の範囲のデータ	  	          実数形式データタイプ      	  	    fload		±1.5*10-45~±3.4*1038	  	  	    double		±5.0*10-324~±1.7*10308	  	  	    decimal		±1.0*10-28±7.9*10.2828	        上の表を見ると様々なデータタイプがありますが、実施にはすべてのデータタイプを使わないですね。得によく使いデータタイプなら「string」、「int」、「double」、「decimal」のことです。参考に「double」と「decimal」の場合は実数系のデータタイプなので、簡単な「1+1」ほどの計算式でこの変数を使うと逆に無用なデータサイズになるので、プログラム性能が遅くなる原因になります。でも、]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/43.html</guid><pubDate>Thu, 25 Jul 2019 23:16:28 +0900</pubDate></item><item><title>[Java スタディ - 4] 演算子</title><link>https://www.nowonbun.com/44.html</link><description><![CDATA[こんにちは。明月です。演算子とはそのとおり計算する記号と意味です。普通で数学で使う演算子と同じく、プログラム上でも同じ意味で使っています。基本的に算数の加算「+」、減算「-」、掛け算「*」、割り算「/」があり、余り「%」、比較記号「&amp;lt;」,「&amp;gt;」、論理演算子「%%」、「||」、イコール「==」があります。                    演算子        使用方法		説明                            算術演算子      	  	    ++		++a, a++		値を一つ加算します(前置演算子、後置演算子)	  	  	    --		--a, a--		値を一つ減算します(前置演算子、後置演算子)	  	  	    +		a + b		加算	  	  	    -		a - b		減算	  	  	    *		a * b		掛け算	  	  	    /		a / b		割り算	  	  	    %		a % b		余り	  	          関係演算子      	  	    &amp;gt;		a &amp;gt; b		「a」が「b」より大きいなら「true」を返還、小さいか同じなら「false」を返還	  	  		&amp;gt;=		a &amp;gt;= b		「a」が「b」より大きいか同じなら「true」を返還、小さいなら「false」を返還	  	  		&amp;lt;		a &amp;lt; b		「a」が「b」より小さいなら「true」を返還、大きいか同じなら「false」を返還	  	  		&amp;lt;=		a &amp;lt;= b		「a」が「b」より小さいか同じなら「true」を返還、大きいなら「false」を返還 	  	  		==		a == b		「a」と「b」が同じなら「true」を返還、違うなら「false」を返還	  	  		!=		a != b		「a」と「b」が違いなら「true」を返還、同じなら「false」を返還	  	          論理演算子      	  		&amp;lt;&amp;lt;		a &amp;lt;&amp;lt; b		整数「a」の２進数値を左側に「b」ほど移動させ、余りは「0」にする。	  	  		&amp;gt;&amp;gt;		]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/44.html</guid><pubDate>Thu, 25 Jul 2019 23:38:33 +0900</pubDate></item><item><title>[Java スタディ - 5] 制御文 - 分岐 (if, switch〜case)</title><link>https://www.nowonbun.com/45.html</link><description><![CDATA[こんにちは。明月です。制御文とはプログラムの処理順番を制御するか繰り返して処理する文法と言います。単純に制御文はこれだって言うのは難しいですね。基本的にプログラムは人間と同じく上から下向き、左から右向きに読み込んで処理します。それなら単純に演算子だけ使って「int」型のデータを１から１００まで加算すると思えば、１から１００まで「+」記号で加算して解決します。(アルゴリズム的には考えなく、単純に考えて)これをプログラム的に表現すると下記通りになりますね。単純な数計算がこの頃ならもっと複雑な計算がどんなふうになるか恐ろしいですね。その時に使う文法が制御です。制御文法はjavaだけではなく、c言語、c++、c#などもすべて同じ文法で動きます。リンク - [c# スタディ - 9] 制御文 - 分岐 (if, switch〜case, goto)リンク - [c# スタディ - 10] 制御文 - ループ(for, while, do〜while, foreach)リンク - [c# スタディ - 11] 制御文 - ループ分岐(break, continue)ここでは制御文の中で分岐文に関して説明します。if ~ else if ~ else 文- if ~ else if ~ else文は条件の値によって(「true」、「false」)処理する制御文です。初めの例はif条件で「check」の値が「true」なので、「number 1 true」がコンソールに出力しました。２つ目の例はif条件で「check」の値が「false」なので、else式に入って「number 2 false」をコンソールに出力しました。３つ目の例はif条件でcheck2の値は「3」ですが「check2 == 1」を計算すれば「false」の結果がでます。なので、次の条件に行きます。次の条件は「check2 == 3」は「true」ですから、コンソールに「number3 true 2」がコンソールに出力します。switch ~ case 文- switch ~ case文は数式によってデータが一致するとこを処理する多重選択文です。上の条件式を見ると「switch」の条件は「4」のデータが設定されています。そして条件の値と「case」の値が一致する条件の文章式を実行されます。もし、一致するデータがなければ、「default」のデータが実行]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/45.html</guid><pubDate>Fri, 26 Jul 2019 23:28:01 +0900</pubDate></item><item><title>[Java スタディ - 6] 制御文 - ループ (for, while, do~while)</title><link>https://www.nowonbun.com/46.html</link><description><![CDATA[こんにちは。明月です。以前、制御文の中で分岐文に関して勉強しました。実は一つのページでやろうと思いましたが、以外に量が多くて分岐、ループ、ループ分岐で分けました。link -  [java スタディ - 5] 制御文 - 分岐 (if, switch〜case)このページでは制御文の中でループに関して説明します。ループって言うのは作成した処理を繰り返して実行するという意味になります。例えば、「int」型の変数に「1」を「100」回に加算したいといえば、ループの制御文を使うことです。ループには3パタンがありまして、下記とおりに説明します。for文- for文は初期値を終了条件まで「false」になるまで初期値を増加され、繰り返して文章を実行する制御文です。初期値には「i=0」、条件式「i&amp;lt;10」、増加値「i++」がなっています。つまり、「i」の変数には初期値で「0」を入力します。条件式で「i&amp;lt;10」なので初めは「true」になります。条件式で「true」になると「system.out.println(i)」を実行します。結果はコンソールで「i」の値、つまり「0」を出力しますね。文書が終わると「i」の値を「1」を増加します。「0」から「1」になります。また条件式を見れば「i」の値は「10」より小さいので「true」になります。「true」なので「system.out.println(i)」が実行します。その続き、「i」が「10」になるまで繰り返しますね。while文- while文は条件式が「true」の場合に実行する、ループ制御文です。こんにちは。明月です。以前、制御文の中で分岐文に関して勉強しました。実は一つのページでやろうと思いましたが、以外に量が多くて分岐、ループ、ループ分岐で分けました。link -  [java スタディ - 5] 制御文 - 分岐 (if, switch〜case)このページでは制御文の中でループに関して説明します。ループって言うのは作成した処理を繰り返して実行するという意味になります。例えば、「int」型の変数に「1」を「100」回に加算したいといえば、ループの制御文を使うことです。ループには3パタンがありまして、下記とおりに説明します。for文- for文は初期値を終了条件まで「false」になるまで初期値を増加され、繰り返して文章を実行する制御文]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/46.html</guid><pubDate>Thu, 1 Aug 2019 20:41:49 +0900</pubDate></item><item><title>[Java スタディ - 7] 制御文 - ループ分岐 (break, continue)</title><link>https://www.nowonbun.com/47.html</link><description><![CDATA[こんにちは。明月です。ループを使う時に特定な条件で繰り返し作業を止まりたい時があります。または、特定条件だけスキップした時があります。例えば、「for」文で「1」から「10」まで繰り返しますが、偶数だけ「system.out.println」で値を出力したいの条件です。ループの中で制御するループ制御です。break文- 「break」文は用法が２つがありますが、一つは「switch~case」文で次の「case」に行けないようにする方法とループの中で繰り返すを止まる用法があります。上の例を見れば、「data」の変数に「1」の値を入力しました。「switch ~ case」には当然に「case」の「1」のところが実行します。では「2」まで実行されました。理由は「case 1」のところで「break;」がないのでそのままで進んで「2」まで実行されました。「case 3」の場合は上の「break」文があるので、止まりました。上の例を見れば、「while」のループで条件は「true」に設定しました。条件が常に「true」なので無限ループになりますね。無限ループはループの条件で終わらないループの意味です。では「while」の処理文書の中で「if」の制御を入れて「i」の値が「10」より大きい場合に「break」を実行しようの処理文章がありますね。意味としては「i」が「10」以上になると「while」のループを「止まる」と意味になります。結果は「0」から「10」の値が出力しました。continue文- 「continue」文は「break」文と英語意味では逆ですが、プログラム処理は逆ではなく似てます。「continue」の場合は「switch」文では使えなく、ループ文だけ使えます。「continue」文はループ中で会わば「break」の場合はループが止まることだったんですが、「continue」の場合は次の条件式に移動する意味(?)です。上の例を見れば、一応「break」文は「i」の値が「10」を超えると掛けます。下で「i % 2 == 1」の意味は「i」を「2」で割って残りが「1」の場合に「continue」してって意味ですね。すなわち、奇数の場合に「system.out.println」で「i」の値が出力することを実行せず、次のループに移動する意味です。結果は偶数になります。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/47.html</guid><pubDate>Fri, 2 Aug 2019 22:47:31 +0900</pubDate></item><item><title>[Java スタディ - 8] 配列(Array)</title><link>https://www.nowonbun.com/48.html</link><description><![CDATA[こんにちは。明月です。配列は変数を一つのデータタイプで集まりの概念だと理解しやすいと思います。資料構造的にお話すると「同じデータタイプのデータを連続的に格納するような資料構造的な変数」という正義していますね。例えば「int」タイプの変数が「100」個が必要な時、配列がなければ変数名を「100」を作成して宣言する方法があります。では実際にそんなに作業すると作業が大変です。配列の場合はもっとしやすく、少ないコーディングステップで運用ができます。oopの本を見ると配列の正義で「メモリ構造上で配列の場合は連続的に割り当てるので、処理時間を改善することができます。」ということになりますが、最近はハードウェアのスペックの発達でパフォーマンス改善より可読性ため使うことが多いですね。配列は「new」キーワードで宣言します。「new」キーワードは配列宣言よりクラスの割り当てることの意味が強いので「class」のパートで詳しく勉強します。「int」タイプの「ret」の変数に配列を「10」個を宣言しました。そして、配列でデータを入力して出力する例ですね。入力時には各配列の番号で一行目ずつにデータを入力しましたが、出力する時には「for」を利用してイタレーションパタンで出力しました。link  - [java スタディ - 6] 制御文 - ループ (for, while, do~while)配列は上の例みたいに普通は一次元的に配列を使いますが、二次元、多次元的な配列も存在しています。上の例を見れば変数名「ret2」に「[10][10]」の二次元配列を宣言して「int」のデータが全て「100」個を入るような変数を宣言しました。二次元配列から「10」個ずつ「10」個のデータがあることになるので、「10」掛け「10」になります。三次元で「[10][10][10]」は「10 x 10 x 10」で「1000」個になります。上の例で「for」の中で「for」を使って「九九」乗算表を配列に入力して出力しましたね。そうすると我々が配列を「2」を宣言してその以上のデータを入力するとどのようになるかな？「indexoutofboundsexception」、すなわちオーバーフローが発生します。そうするといつも配列を使う時に固定な配列個数を決めて静的に使う方しかないかな？と言えば、動的に配列を宣言する方法もあります。上の例を見ると「ret」と言う]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/48.html</guid><pubDate>Thu, 5 Sep 2019 21:24:52 +0900</pubDate></item><item><title>[Java スタディ - 9] 関数 (メソッド、Function)</title><link>https://www.nowonbun.com/49.html</link><description><![CDATA[こんにちは。明月です。これから「oop(object-oriented programming:オブジェクト指向プログラミング)」の核心だと考えられるクラス(class)に関して勉強します。クラスは「java」プログラムの中でメモリの構成単位でプログラムを動けるオブジェクトだと考えられます。データタイプ単位では「int」や「float」などがありますが、オブジェクトとして変数を集まってプロシージャを作成し、実行する単位がクラス(class)だと思います。すなわち、メソッドだけや変数だけではプログラムを作成ができないし、実行することができません。最小単位でクラス(class)が存在しなければならないと意味です。私が今まで特に説明してなかったんですが、「main」関数を呼ばれるように下記とおりに作成しました。例みたいに実行するために「main」関数だけ必要だってもクラス(class)が囲まなければならないです。クラスの場合は下記の要素をもっています。                    クラス要素        説明                            コンストラクタ        クラスの初期処理及び関連機能処理                    メンバー変数        フィールドという呼ばれるグローバル変数                    関数        メソッド            予想よりクラスが持っているメンバーはc#より多くないですね。classは上の例みたいに構成されています。以前に変数と関数に関しては勉強したことがあるので、そんなに違和感がないと思いますが、コンストラクタは関数とは違いますね。コンストラクタは関数と比べてリターンタイプがないです。なぜなら、クラスの生成する時に処理処理をここでするので、リターン値が必要ないからではないかと思いますね。または関数はクラス名と同じ名で作成できません。ではコンストラクタは必ずクラス名とコンストラクタ名は一致しなければならないです。メンバー変数はクラス中で使う変数らしく、変数ですね。すべて前に「public」と言うアクセス修飾子があります。アクセス修飾子に関して様々の理解が必要なので別途で説明します。link - 作成中クラスを宣言するようには「new」キーワードを使います。「new」キーワードに関しても様々お話が]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/49.html</guid><pubDate>Wed, 7 Aug 2019 20:57:23 +0900</pubDate></item><item><title>[Java スタディ - 10] クラス(Class)</title><link>https://www.nowonbun.com/50.html</link><description><![CDATA[こんにちは。明月です。これから「oop(object-oriented programming:オブジェクト指向プログラミング)」の核心だと考えられるクラス(class)に関して勉強します。クラスは「java」プログラムの中でメモリの構成単位でプログラムを動けるオブジェクトだと考えられます。データタイプ単位では「int」や「float」などがありますが、オブジェクトとして変数を集まってプロシージャを作成し、実行する単位がクラス(class)だと思います。すなわち、メソッドだけや変数だけではプログラムを作成ができないし、実行することができません。最小単位でクラス(class)が存在しなければならないと意味です。私が今まで特に説明してなかったんですが、「main」関数を呼ばれるように下記とおりに作成しました。例みたいに実行するために「main」関数だけ必要だってもクラス(class)が囲まなければならないです。クラスの場合は下記の要素をもっています。                    クラス要素        説明                            コンストラクタ        クラスの初期処理及び関連機能処理                    メンバー変数        フィールドという呼ばれるグローバル変数                    関数        メソッド            予想よりクラスが持っているメンバーはc#より多くないですね。classは上の例みたいに構成されています。以前に変数と関数に関しては勉強したことがあるので、そんなに違和感がないと思いますが、コンストラクタは関数とは違いますね。コンストラクタは関数と比べてリターンタイプがないです。なぜなら、クラスの生成する時に処理処理をここでするので、リターン値が必要ないからではないかと思いますね。または関数はクラス名と同じ名で作成できません。ではコンストラクタは必ずクラス名とコンストラクタ名は一致しなければならないです。メンバー変数はクラス中で使う変数らしく、変数ですね。すべて前に「public」と言うアクセス修飾子があります。アクセス修飾子に関して様々の理解が必要なので別途で説明します。link - 作成中クラスを宣言するようには「new」キーワードを使います。「new」キーワードに関しても様々お話が]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/50.html</guid><pubDate>Wed, 7 Aug 2019 21:00:35 +0900</pubDate></item><item><title>[Java スタディ - 11] アクセス修飾子</title><link>https://www.nowonbun.com/51.html</link><description><![CDATA[こんにちは。明月です。このページではアクセス修飾子に関して調べてみます。クラスやメソッドを宣言する時に、「public」、「private」、「protected」などのキーワードをみたことありますね。このキーワードがアクセス修飾子だといいます。アクセス修飾子の役は単語の意味とおりに外部からアクセス制限する形になります。javaの中には下記とおりにアクセス修飾子を提供しています。                    アクセス修飾子                    アクセス修飾子        説明                            public        すべてのクラスでアクセスが可能です。                    private        クラスの中だけアクセスが可能です。                    protected        パッケージで属するクラスと経書されたクラスだけでアクセスが可能です。                                アクセス権限                    アクセス修飾子        クラス        継承されたクラス        同じパッケージ        すべてクラス                            private        ○        ☓        ☓        ☓                    (default)        ○        ☓        ○        ☓                    protected        ○        ○        ○        ☓                    public        ○        ○        ○        ○            eclipseのソースアシスタントの利用して詳しく確認します。「class1」クラスの中には「a1」、「a2」、「a3」の３つの変数があります。この変数たちには違うアクセス修飾子を宣言しました。「class1」の外部「program10」のクラスで見ると「a2」、「a3」だけに見えます。すなわち、「public」、「protected」が見えます。「public」の場合]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/51.html</guid><pubDate>Tue, 20 Aug 2019 00:43:17 +0900</pubDate></item><item><title>[Java スタディ - 12]  Static</title><link>https://www.nowonbun.com/52.html</link><description><![CDATA[こんにちは。明月です。今回は「static」のキーワードに関して調べてみます。「static」とは英語の意味とおりにクラスや変数、メソッドに付ければ静的オブジェクトになるキーワードです。静的オブジェクトの意味は、以前、「java」の中で最小単位がクラスということで勉強しました。そのクラスで変数、メソッドが存在します。そして、そのクラスを使うようには「new」でクラスをメモリに割り当てて使うことになりました。今まで私が説明した流れになります。でも、「static」の場合、そのクラスを割り当てて使うことではなく、プログラムが起動する時に宣言することで、クラスが割当てることがなくても使うことです。説明が難しいですが、クラスを「new」するとメモリ上では別々のデータオブジェクトになりますが、「static」の場合はプログラムの「heap」のメモリで雄一な変数やメソッドになります。(※メソッドは割当てることと関係がないですが、メンバー変数をメソッド中で使うので、この表現にしました。)上の例を確認すれば「main」は「example」クラスの中にあります。そして「main」で「data」クラスを割り当てます。初めのクラスは「d1」という変数名で宣言して「setvalue」関数を呼出し「1000」のデータを入力します。そして「d2」という変数名で「data」クラスを割り当てて、「getvalue」関数でデータを出力します。結果は「1000」になりますね。確かに「d1」と「d2」は別のクラスですが、結果は「d1」の「value」の値、正確に「d1」で割り当てた「value」の値ではなく、「static」で静的になった「data.value」データですね。今回は「static」をすべて外します。今回は「static」を宣言してないので、「d1」と「d2」の値は別々です。当たり前で「d2」の「value」値は「0」ですね。「d1」は「1000」だと思います。実は「static」データはクラス中であってもクラス宣言が必要ないです。上の例では「data」クラスの割当てることがなしで、直接「data.setvalue」で呼出しますね。その意味で我々が初めから使った「main」関数で理解ができます。プログラムがコンパイルして実行する時に「static main」関数を探します。形では「string[]」のパラメータを持っているメソッ]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/52.html</guid><pubDate>Thu, 5 Sep 2019 21:03:35 +0900</pubDate></item><item><title>[Java スタディ - 13] new</title><link>https://www.nowonbun.com/53.html</link><description><![CDATA[こんにちは。明月です。今回は「new」というキーワードに関して調べます。「new」のキーワードは「java」のプログラムで考えずによく使うキーワードですが、実は一番意味ががキーワードだと思います。「new」キーワードをよく使うと複雑なプログラムも簡単に解決するが、間違って使うとプログラムがおかしくしやすくなるキーワードです。以前のページでも簡単に説明したことがありますが、「new」キーワードはクラスをメモリ登録だといいます。c言語の時代には「alloc」だといいます。実の物理的なメモリはパソコンで付いている「ram」ですが、プログラム上でメモリは「stack」と「heap」があります。簡単に説明すると、「stack」は静的で呼出し領域がなくなると値がなくなる特徴があります。「heap」の場合は参照タイプで動的で解除しないとなくならない特徴があります。プログラムではこの２つを繋いで使っています。上の例を見れば、今までよく見てた形ですね。「main」関数で「example」クラスを割当て「example」クラスのコンストラクタで出力していますね。ここで「example e = new example」の形で宣言しました。「example e」の場合は「int a」と同じ形でメモリ構造で見ると「example e」は「int」型の整数があります。実施に「example」クラスのデータがあることではないです。「new example」で「heap」領域に割当て、そのメモリ住所を「example e」に入れる形になることです。すなわち、「example e」は「stack」領域、「new example」は「heap」領域で宣言して「=」で連携することですね。説明が難しいです。例をみれば、「example a」と「example b」を宣言して「a」には「new」キーワードを使って割当てました。「b」の場合は「b = a」にしました。そうして「a」に「10」の値を入力して「b」には「20」の値を入力しました。その後、「a」のデータを出力すると「20」の値が出力しますね。なぜなら、「heap」メモリには一回だけ割当てて「a」と「b」変数には同じメモリアドレスを入力しました。すなわち、「a」にあるクラスと「b」にあるクラスは同じなので「b」で値を変更すると「a」にもデータが変わりますね。次はメモリアドレスでもっと詳しく]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/53.html</guid><pubDate>Thu, 22 Aug 2019 00:07:44 +0900</pubDate></item><item><title>[Java スタディ - 14] クラス継承</title><link>https://www.nowonbun.com/54.html</link><description><![CDATA[こんにちは。明月です。このページではクラス継承に関して調べてみます。クラス継承とはクラスの特性を継承して再定義することということです。すなわち、「a」と「b」のクラスを作成します。「b」クラスは「a」クラスの形が同じですが、「b」クラスの場合は特別に処理する関数及びメンバー変数が追加される形になります。上の例を見ると「aclass」と「bclass」があります。「aclass」、「bclass」を見ると「dataa」変数と「setdataa」、「print」関数が同じですね。「bclass」が「aclass」より「datab」と「setdatab」、「printall」が追加している形ですね。実際にプログラミングするとこのケースが多いです。似ているな形ですね。ここで「print」関数を変更したいというと「aclass」、「bclass」を修正しますね。もし、こんなケースのクラスが「100」個以上なら？すべて修正しなければならないなの？上の例をみれば「bclass」に「extends」キーワードを使って「aclass」を継承しました。すなわち、「bclass」には「dataa」変数と「setdataa」、「print」関数があることと同じです。「printall」関数をみれば「print」関数を呼出してもエラー表示がされないですね。その上で「print」変数を修正したいなら？「aclass」の「print」関数だけ修正すれば解決です。すなわち、こんなケースが「100」こあっても「aclass」の修正だけ「ok」になります。継承の意味はわかりました。そうすると形は同じだけど、「print」関数だけ再定義したい時もありますね。上の例をみれば「bclass」で「@override」のアノテーションを付けって再定義しました。そのことはbclassで「printall」関数を呼び出せば、「aclass」の「print」ではなく、「bclass」の「print」が呼び出せますね。「bclass」の「print」関数には「aclass」の「setdataa」の関数を呼出し、「dataa」の変数を再設定しますね。まだ「this」、「super」に関して説明してなかったので、「base.print」の場合は「aclass」の「print」を呼び出すと思えばよいです。「this」、「super」は次にページで説明します。結果を]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/54.html</guid><pubDate>Thu, 22 Aug 2019 20:09:31 +0900</pubDate></item><item><title>[Java スタディ - 15] thisとsuper</title><link>https://www.nowonbun.com/55.html</link><description><![CDATA[こんにちは。明月です。このページでは「this」と「super」に関して調べてみます。前のページで「クラス継承」に関して調べてみました。リンク - [java スタディ - 14] クラス継承その中で簡単に説明しましたが、「@override」という関数再定義がありました。それと関係があるものですが、クラスが継承する時及びメンバー変数とローカルを変数を区分するように必要ですが、それが「this」、「super」です。上の例をみれば、「aclass」の中で「value」のメンバー変数と「setvalue」と「getvalue」の関数がありました。「setvalue」をみれば、「パラメータ」名が「value」ですが、メンバー変数も「value」のことがあり、メソッドの中では「value」の変数名はなんの変数を向かっているかしらないですね。すみません、知らないことではなく、一番近いのローカル変数をみることになっています。すなわち、「value」変数を使うとローカル変数を見て、もしかしてローカルで変数名がなければメンバー変数も見ますね。両方なければエラーが発生します。では上みたいにメンバー変数名とローカル変数名が同じことがある場合、ローカル変数をみることは知りますが、メンバー変数をどうふうに見ますかっていうとその時に「this」のクラスを使います。基本的に「this」と言うのは”自分のクラス”ということでクラスの中の変数、すなわちメンバー変数を向かいますと意味ですね。結論は上の例「this.value = value」の意味はパラメータ「value」からメンバー変数「value」にデータを入力することの意味になります。そうするとクラス経書の場合はどうするか。実は例みたいにメンバー変数を「protected」に設定しませんが、説明のため実装しました。上の例を見ると「bclass」の場合は「aclass」を継承します。「bclass」の「setvalue」の関数をみれば、上位クラスのメンバー変数の「value」もあるしメンバー変数の「value」があるし、パラメータの「value」もあります。例とおりに「super」は上位クラスの「value」を見ることになります。この場合はどうするか。。「super」の場合は直前の上位クラスを参照するので、aclassの変数ができません。ただ、上みたいに同じ変数名や関数名がそうです]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/55.html</guid><pubDate>Fri, 23 Aug 2019 19:46:50 +0900</pubDate></item><item><title>[Java スタディ - 16] インタフェース</title><link>https://www.nowonbun.com/56.html</link><description><![CDATA[こんにちは。明月です。このページではインターフェースに関して調べてみます。インターフェースとは一般クラスと違いますが、処理式と変数がない形だけあるクラス(?)、すなわち、「new」ができないクラス(?)と言います。つまり、「heap」メモリに割当てるのができなく、「stack」だけメモリアドレスを宣言する形になるクラスです。クラスといいますが、インターフェースですね。そうなら、なぜ処理式がなしで形が￥だけあるインターフェースがあるか？プログラムを作成する時に本当に割当てるクラスだけではなく、形だけで宣言してデータを扱う時がありますね。上の例を見れば、時にプログラム上で問題がありません。「print」関数のパラメータで「true」を入れると「class1」の「print」が実行して結果が出力するはずですね。または「false」を入力すると「class2」が出力します。でも、私の場合はクラスをリターンしてクラスの値をもらいたい時にどうすればいいかな？確かに上のクラスが違うので、一つの返却データタイプで決めて返却はできないですね。じゃなければ、「object」タイプで返却をもらうことができますが(※javaはすべてのクラスが「object」タイプを経書しています。)、「object」タイプには「print」関数がないので、「print」関数を呼出すのができないですね。上の例を見れば、「eclipse」でエラーが発生しますね。そうです。そのために、インターフェースが必要ですね。上の例を見れば、「interface」を宣言して「interface」中で何を使うかのメソッドを宣言します。参考に「interface」は処理式と変数は要らないです。なのでアクセス修飾子も要らなく、全て「public」だと思ったらよいです。また、「main」関数に戻って「print」関数を呼出すと「interface1」の形式でリターンします。でもそのインタフェースは「true」の場合は「class1」を「false」の場合は「class2」のデータを持っています。インタフェースの場合はリターン式のためではなく、クラスを纏めて処理式を作ることも可能ですね。上のみたいに戦略的に設計も可能です。実際に「interface」は「oop」で重要なキーワードで本当に「oop」らしくプログラミングができるようにするキーワードですね。後で、デザインパター]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/56.html</guid><pubDate>Thu, 5 Sep 2019 20:55:19 +0900</pubDate></item><item><title>[Java スタディ - 17] 抽象クラス</title><link>https://www.nowonbun.com/57.html</link><description><![CDATA[こんにちは。明月です。このページでは抽象クラスに関して調べてみました。抽象クラスはインタフェースと一般クラスを混ぜている形だと思ったら理解しやすいです。(※実はそれではないけれども、その形ですね。)抽象クラスはクラスという名を持っていますが、クタスみたいに「new」して割当てができません。でも、インタフェースみたいに処理式及び変数がないことではなく、あります。抽象クラスは一般クラスの上位クラスで共通処理を集まると意味がありますね。上の例をみれば、「abstractclass」があります。「abstractclass」の中で「run」関数があり、「run」関数の中では「print」関数を呼出しますね。でも、「print」関数は抽象において継承クラス側から作ることにします。「abstactclass」を継承した「class1」のクラスの場合は「print()」を再定義します。「main」関数でみれば、「abstractclass」指示子に「class1」を割当てます。その中で「run」関数を呼出すと「print」関数を呼びます。「print」関数は継承されたクラスから再定義します。つまり、「class1」の場合は「class1」の「print」関数を「class2」の場合は「class2」の「print」関数を呼びます。ここまで、インタフェースと抽象クラスを調べてみました。インタフェースと抽象クラスは「oop」ですごく重要な概念ですね。特にデザインパターンでインタフェースと抽象クラスを利用して様々の設計パターンがあります。下記はデザインパターンでデコレーションパターンの一部です。上をみれば、インタフェースから経書して抽象クラス、一般クラスまで継承してますね。デコレーションパターンはプログラム可読性とクラスファイル整理がしやすいので、使いますね。後、機会があれば、詳しく説明します。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/57.html</guid><pubDate>Tue, 27 Aug 2019 19:06:12 +0900</pubDate></item><item><title>[Java スタディ - 18] 列挙型(enum)</title><link>https://www.nowonbun.com/58.html</link><description><![CDATA[こんにちは。明月です。このページでは列挙型に関して調べてみました。列挙型に関しては「java」だけあることではなく、「c#」でも同じ意味であるのでご参考してください。link - [c# スタディ - 18] enum(列挙型)列挙型とは、プログラミングする時にタイプやステータスを表現する時にありますね。でも、そのステータスをただ、「int」型で値を「1」や「0」に表現すると皆にプログラム可読性が悪くなります。上の例を見れば、「print」関数で「int」タイプのパラメータを受け取って、「1」の場合と「2」の場合、「3」の場合を分けって処理することになります。上の例はすごく簡単な例なので、「int」型でしてもそんなに難しいとは思わないですが、プログラムが複雑になれば悪いコードになります。そのためあることが列挙型です。上の例をみれば、列挙型の「printtype」を宣言しました。「print」関数でパラメータタイプを「printtype」にして「main」関数で「printtype」を入れることを確認できますね。そのとおりにプログラムを作成すると確かに以前みたいに「1」と「2」で数字だけの意味ではなく、宣言文字の意味を与えて使用ができますので、プログラムの可読性が上がると思いますね。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/58.html</guid><pubDate>Mon, 2 Sep 2019 20:31:06 +0900</pubDate></item><item><title>[Java スタディ - 19] 例外処理( try ~ catch)</title><link>https://www.nowonbun.com/59.html</link><description><![CDATA[こんにちは。明月です。このページには例外処理に関して調べてみました。例外処理とはプログラムを作成しながら予想できなかった部分を処理することを例外処理といいます。例えば、除算する関数を作ると考えたら、その関数はパラメータを2つをもらいます。1つめのパラメータは除算する対象、2つめのパラメータは分ける数ですね。でも、2つめのデータを「0」をもらうとどのようになるかな？上の例を見れば、「10」から「2」を分けった時には確かに「5」の結果になりますね。でも、「0」になった時にはコンソールタブで赤い文字でエラーメッセージが出ました。その後で「10」から「5」を分ける構文は実行しなくてシステムが止まりました。もちろん、「division」関数で「val2」が「0」の場合は「if」を作成してエラーがならないようにできます。今回は簡単なプログラムなので問題ないですが、複雑なプログラムの場合はすべての例外を予想して作成はできないですね。そのため、例外処理があります。上の例をみれば、「division」関数で「try ~ catch」構文がありますね。「try」はエラーが発生する可能性がある範囲、「catch」の場合はエラーが発生する時に処理する構文ですね。上の例は「0」でエラーが発生しましたから、コンソールで「error」を出力して「0」をリターンしますね。例外処理は「try ~ catch」ですね。そうすると「catch」のキーワードで「exception」というクラスが宣言しています。その意味はエラー処理別で処理する分岐ですね。上の例をみれば、「arithmeticexception」の「catch」を作って実行しました。結果は「zero error」が出力しました。その意味ではエラー別で分岐して処理ができると意味です。「exception」の場合は例外処理の上位クラスなので、「arithmeticexception」の以外のエラーは「exception」になります。(※一番上位インタフェースは「throwable」です。「throwable」は「runtimexception」と「exception」になります。「runtimeexception」と「exception」の差は少し後で説明します。)そうすると意図的に「exception」も作ることができます。上の例をみれば、「print」関数でパラメータが「0」より]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/59.html</guid><pubDate>Tue, 3 Sep 2019 20:50:12 +0900</pubDate></item><item><title>[Java スタディ - 20] 匿名クラス、そしてラムダ式(Lambda expression)</title><link>https://www.nowonbun.com/60.html</link><description><![CDATA[こんにちは。明月です。このページは匿名クラスとラムダ式に関して調べてみました。匿名クラスとは言うとおりにクラス名がないことを言います。クラス名がないならどのように実装するかと思いますが。簡単に説明するとインタフェースの指示子で別に実装されたクラスではなく、直接に「new」キーワードだけ使ってクラスを宣言する方法だと思われます。説明が難しいですね。上の例をみれば、インタフェース「exampleinterface」を実装しました。「main」関数で指示子「exam」をインタフェース「exampleinterface」で宣言しました。そうすると基本的に我々の知識だとクラスを割当て使いますね。でも、実装したクラスではなく、「new インタフェース名」で宣言して「override」でクラスを継承しますね。すなわち、別にクラスを作ることではなく、直接にクラスを作ることです。下で「setdata」で「10」の値を入れて、「print」関数で出力しました。普通のクラスと使う方法が同じですね。匿名クラスは普通のクラスと別に差異がないですね。別に普通のクラスを宣言して使ってもいいと思いますが、なんで匿名クラスを使うかと言えば匿名クラスはラムダ式と関係があります。我々が一回用のため、一つ一つクラスをすべて宣言するとプロジェクトサイズが大きくなりますね。ラムダ式とはクラス名とメソッド名を省略して一つのメソッド式で表現した文法といいます。簡単にいうと匿名クラスでメソッド名まで省略したいということですね。上の例を見れば、「exampleinterface」のインタフェースに「print」の関数がありますね。それを「run」関数でパラメータとしてインタフェースを受けています。「main」関数で「run」を呼出しますが、ラムダ式( () -&amp;gt; { } )でデータを渡します。ラムダ式の条件はインタフェースの中で一つのメソッドの時に使われますが、もしメソッドが2つ以上ならラムダ式を使えません。ラムダ式は上の例みたいに「void」だけではないです。上の例みたいに、パラメータ設定も可能だし、リターン値設定も可能です。ラムダ式の条件ではインタフェースで一つのメソッドがある時に使うことですが、その条件せいでよく使うインタフェースがあります。それは「runnable」ですね。上のイメージをみれば、インタフェースで一つのメソッドの条件があ]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/60.html</guid><pubDate>Wed, 4 Sep 2019 20:12:19 +0900</pubDate></item><item><title>[Java スタディ - 21] IO(Input / Output)</title><link>https://www.nowonbun.com/61.html</link><description><![CDATA[こんにちは。明月です。このページはjavaで使うio(input / output)に関して調べてみました。ioとは(input / output)の略語でただinputのキーボードとoutputのモニターの意味ではなく、ファイルのinputのファイル作る、ファイルのoutputのファイルを読込みのいみですね。すなわち、プログラムでioというのはファイルを扱うと意味になります。一応、この「input / output」を理解するようには「byte[]」配列と「stream」に関して認知しなければならないです。我々がプログラムで使うデータは結局、計算してどこかで格納するか、出力するか(印刷とか、モニターに結果を表示か)、どこかで通信してデータを渡すかになりますね。そのデータをデータ化するようにはバイナリー形式に変換します。バイナリーとは機械が認識できるような2進ファイルですね。その2進ファイルの一つのデータがjavaでは「byte」形式になっています。なので、バイナリーデータは「byte[]」配列になっています。javaで使うデータタイプでは「int」型があります。この「int」はすべて「4byte」になっていますね。「4byte」になっていることの意味では「int」型をバイナリーにすると「byte[4]」になります。もし、上の「4byte」で順番が変わったり、「4byte」の[0]と[1]が「0」なので、省略しますと思うと、データが「1000」にならないですね。初めから「int」が「4byte」だから「2byte」で格納するとデータが「int」に戻れません。なので、連続なデータの流れ、上のデータを「byte[]」単位の結ぶかたをプログラムでは「stream」と言います。「stream」は「i/o」と「socket」通信などと関係がたくさんありますね。テキストファイルをプログラム側に読込む時に「stream」形式で受け取るし、データをファイルに書出す時にも「stream」形式を利用します。上の例をみれば、「fileinputstream」でファイルを読み込んで、コンソールに出力しました。結果は「test.txt」と同じ文言が出力しますね。今回は逆にデータ内容をファイルに書出します。上の例をみれば、すべて「stream.close()」の関数を呼出しています。なぜなら、「i/o」にはコネクションがありますが、]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/61.html</guid><pubDate>Thu, 5 Sep 2019 22:59:10 +0900</pubDate></item><item><title>[Java スタディ - 22] ジェネリック(Generic type)</title><link>https://www.nowonbun.com/62.html</link><description><![CDATA[こんにちは。明月です。このページはジェネリック(generic type)に関して調べてみました。クラスの基本構成はメンバー変数、関数になります。上の例はstackアルゴリズムを実装しました。stackアルゴリズムは「push」、「pop」の関数でなっているアルゴリズムです。「push」の順番で「pop」のより一番最後に入力されたデータが一番最初に出る構造です。(filo構造)上のアルゴリズムでパラメータは「object」型になっていますね。なので「string」や「int」や「float」、「double」のデータタイプでも入力します。でも、「pop」にして使うようには「object」型なので、ユーザによってデータタイプを知らないですね。逆にデータキャストをしなければならない構造です。そうすれば「object」ではなく、データタイプをクラス内部ではなく、外部で決める方法がないかというとそれをジェネリック(generic type)で解決できます。eclipseのコードアシスタントを確認しても「pop」関数の返却タイプが「integer」になっているし「push」のパラメータも「integer」タイプになっていますね。我々がよく使う関数「list」タイプでもすべてジェネリック(generic type)になっていますね。ジェネリック(generic type)は単純なキーワードですが、プログラムのデータ正誤性のため、様々のところで重要なキーワードですね。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/62.html</guid><pubDate>Fri, 6 Sep 2019 22:34:14 +0900</pubDate></item><item><title>[Java スタディ - 23] Streamフィルタ式</title><link>https://www.nowonbun.com/63.html</link><description><![CDATA[こんにちは。明月です。このページはstreamフィルタ式に関して調べてみました。以前、私が「i/o」に関して説明する時にstreamについて説明したことがありますね。link - [java スタディ - 21] io(input / output)意味としてはその時に同じですが、今回はlistやmapにあるデータを「stream」型に変わって検索、ソートなどをすることです。説明が難しいですが、例で説明します。上の例をみれば、「list」に「0」から「9」までのデータを入れました。そのリストで私は偶数を抽出したいですね。なので、「filter」関数を作って偶数を抽出して返却しました。なので上みたいなソースが実装されました。でも、ただ「int」型のリストで抽出でも複雑ですね。ただ「int」系ではなく「class」タイプならどうかな。もっと複雑になりますね。プログラミングでデータ抽出やソート処理がすごく多いですね。それを簡単に処理するような文法がstreamフィルタ式です。使用方法はリストの場合に「stream()」で変換します。「filter」関数で中はラムダ式ですね。形式はリターン値が「boolean」タイプでパラメータはリストの一つのデータが繰り返して出ます。繰り返して出たデータでリターン値が「true」場合にstream式に残ります。「collect」関数で「list」タイプに変換して返却しますと意味ですね。他の例です。上の例では３つの例を作成しました。初めはリスト形式をマップ形式に変換しました。「collect」関数でパラメータは「キーになるデータを取得する関数名」と「キーによってなるデータ」でマップを作ります。「tomap」の場合は一つのキーで一つのデータを作成することですが、もし重複キーがある場合あにはエラーになります。その時には「groupingby」関数を利用してマップを作れば、キーによってリストデータで紐付きます。後、「toarray」を利用してリストを配列にも変換できますね。最後は「findany」や「findone」関数がありますが、その関数は一つのデータを出力します。すなわち、フィルタで一つの結果を予想する時に使います。でも、上の関数は「optional」クラスに変換しますが、「optional」関数は「null」などの検索結果が正しい可否をチェックするようなクラスですね。例えば、「]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/63.html</guid><pubDate>Tue, 10 Sep 2019 22:18:42 +0900</pubDate></item><item><title>[Java スタディ - 24] スレッド(Thread)、同期化(synchronized)、デッドロック(deadlock)</title><link>https://www.nowonbun.com/64.html</link><description><![CDATA[こんにちは。明月です。このページはスレッド(thread)、同期化(synchronized)、デッドロック(deadlock)に関して調べてみました。スレッド(thread)とはどのプログラム内で、特にプロセス内で実行する流れの単位といいます。私が今まで「main」からプログラムを作成して実行したことが一つのスレッドで動きましたが、状況によって一つの以上のスレッドも運用できます。そのことをマルチスレッドといいます。スレッドの意味は「java」だけではなく、全てプログラム言語、システム内でいうスレッドの意味は全て同じです。一般的にプロセス内で複数のスレッドが存在しますが、各独立的な並列の流れです。上の例をみれば、「thread1」と「thread2」を実行します。スレッドの内ではループで「0」から「100」まで繰り替えしてコンソールで出力します。「thread.sleep」の場合はスレッドを止まると意味で単位は1ミリ秒です。なので「1000」は「1秒」になります。普通の我々の知識だと「thread1」が終わって「thread2」が実行しそうですね。でも実際には「thrad1」と「thread2」が同時に動いています。また、スレッドを呼出す時に呼出した関数が違いますが、「start」と「run」がありますね。「start」の場合はスレッドが終了するところまで待ちなく、次のステップに行きますが、「run」の場合はスレッドが終了するまでステップを待ちます。上の例は一つのクラスのデータを２つのスレッドで共有して加算することです。初めのスレッドで「0」から「100」まで加算、２つめも「0」から「100」まで加算ですね。「0」から「100」まで加算は「100」ですが、予想値は「200」ですね。でも結果は「195」ですね。理由は「ex.data++」のことは加算ですが、内部で「int buffer = ex.data + 1 ; ex.data = buffer;」で動いていますね。スレッド1で「ex.data」は「0」でした。そこで「1」になることですが、当時にスレッド2でも「ex.data」が「0」ならスレッド1とスレッド2で二回に加算しますが、結果は「1」になることです。私が考えることはスレッド1で加算するとその後でスレッド2で加算して「2」になることを予想しますね。上みたいにするようには同期化が必要です。同期化]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/64.html</guid><pubDate>Wed, 11 Sep 2019 23:06:43 +0900</pubDate></item><item><title>[Java スタディ - 25] スレッドプール(ThreadPool)</title><link>https://www.nowonbun.com/65.html</link><description><![CDATA[こんにちは。明月です。このページではスレッドプール(threadpool)に関して調べてみました。以前までスレッド(thread)に関して説明しました。スレッド(thread)とは並列処理でプロセス内で同時に処理ができることです。そのため、データを共有するように同期化(synchronized)によってデータの無欠性を守ることにします。スレッドの場合はシステムの性能関係なく、無限に生成ができます。適切なスレッド生成は並列処理でプログラムの性能を上げることができますね。でも、スレッドは無限に生成できると思っても、パソコンの物理的な容量は限界がありますね。無限にスレッドを生成することでプログラムが指数的に性能が上がることではなく、限界が至ると結局スレッドを実行するリソースでシングルスレッドより遅くなる段階になりますね。その意味では、スレッド個数を制御するし、リソースを再使用することでプログラムの性能をあがることができます。スレッドプールはシステムによってスレッド個数を制御するし、スレッドのステップが終わったものだってもリソース解除ではなく、次のスレッドに再使用することでリソースを節約することができます。「executors.newsinglethreadexecutor()」はスレッドプールの中で一つのスレッドを利用する例です。結果をみれば１番目、２番目、３番目を実行しても順番通りにスレッドが動きます。スレッド名も「thread1」で同じスレッドになっていますね。「executors.newcachedthreadpool()」はスレッドプールの中でスレッドスレッド個数を最大に「int」のサイズほど生成ができます。システム性能によって限界がありますが、かなり多くスレッドを生成できます。でもシステム中では一つのプログラムがあるので、パフォーマンスを最大まで使うのは危ないですね。スレッドプールでスレッドリソースを再使用すると機能がなければ、別に一般「thread」を生成することと差異がないと思いますね。スレッド２つだけ使うスレッドプールを生成したので、結果をみれば初めにはスレッドを２つを利用して２つのスレッドが終了すると「thread1」は再使用するして一つのスレッドに展開することを見えますね。その以外のスレッドプールの種類は「newscheduledthreadpool」,「newworkstealingpoo]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/65.html</guid><pubDate>Fri, 13 Sep 2019 00:59:53 +0900</pubDate></item><item><title>[Java スタディ - 26] アノテーション(annotation)</title><link>https://www.nowonbun.com/66.html</link><description><![CDATA[こんにちは。明月です。このページではアノテーション(annotation)に関して調べてみましたjavaのアノテーションはc#のアトリビュートと似てる意味になります。link - [c# スタディ - 34] attribute(アトリビュート)アノテーションとはクラス、メソッド、変数なのでメタデータ、あるいはデータの正義するデータと言います。つまり、アノテーションデータとしては実施にプログラムの実行で使えるデータではなく、クラス、メソッド、変数のデータを区分するようなデータだといいますね。c#側ではアトリビュートのデータを使うことがありますがそのことと少し差異があります。上の「override」、「deprecated」アノテーションはjavaプログラムで一番よく見るアノテーションですね。詳しく説明すると「override」アノテーションはクラスが経書された時にメソッドを再正義を明示する時に使うアノテーションです。「deprecated」は実際にメソッド削除をできないし(様々で使うところがありコード変更がすごく必要な状況)、これからメソッドを使えないように使うアノテーションです。「override」と「deprecated」は基本的にjavaにあるアノテーションです。では、実際にアノテーションを使うと言うとクラスやインタフェースみたいにアノテーションを生成して使いますね。上の例をみれば「testannotaion」の名のアノテーションを生成しました。「target」のアノテーションを利用して「method」を選択しまいたが、「all」を選択すると全ての形で使えるし、「class」を選択するとクラスで、「field」を選択すると変数で使えるアノテーションを作られます。上の例では「method」を選択しましたので「node」クラスで「print」関数でアノテーションを選択しました。アノテーションの設定に関してはここまでですが、ただアノテーションだけではなぜこの設定をするかを理解しにくいですね。アノテーションは様々なフレームワークやライブラリでたくさん使われますが、なんのため設定するかを意味を知らない場合があります。ライブラリでクラスを読み込む時に設定のために使われますが、この部分は「java」の「reflection」と関係があるので、その時に詳細に説明します。link - 作成中 ]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/66.html</guid><pubDate>Fri, 13 Sep 2019 20:04:31 +0900</pubDate></item><item><title>[Java スタディ - 27] ソケット(Socket)通信</title><link>https://www.nowonbun.com/67.html</link><description><![CDATA[こんにちは。明月です。このページではソケット(socket)通信に関して調べてみました。ソケット(socket)とは「java」だけではなく、「c / c++ / c#」などのプログラム言語にも通信に関しては同じ意味になります。我々が通信する時に転送するデータ(packet)がパソコンからランケーブルによって行きます。そしてランケーブルからルータ、dns順で移動します。その移動されたパケットはまたルータによって目標したパソコンに転送され、プログラムから読み込まれて処理して通信がなります。我々が通信開発するお時、上のパケット移動する形を全て設定するしプログラミングをしません。この通信形はos段階で設定され(osi 7階層)、最終プログラムでソケットを利用して通信を行います。つまり、「全ての設定されたところで挿し込んで使います。」と意味でソケットの通信といいますね。link - osi参照モデルソケットの使用方法と流れに関して説明します。ソケットはサーバがローカルipをもってportを開いて(bind)クライアントの接続を持っています。(listen)そしてクライアントはサーバipアドレスとポート番号で接続(connection)して連結すれば、サーバとクライアントは「send」、「recieve」の形でパケットを送信、受信します。お互いに通信がおわれば、「close」で接続を切ります。イメージソース：https://www.ibm.com/support/knowledgecenter/ja/ssw_ibm_i_71/rzab6/howdosockets.htmこれからプログラムで確認します。上のソースを起動してlistenしている状況を確認します。上のイメージをみれば「9999」ポートでちゃんとlistenしていることを確認できました。次はクライアントを作成します。コンソールでサーバから受け取ったデータで「hello world」というデータがちゃんときました。また、サーバ側に戻って確認します。サーバ側には「ok」というデータをちゃんと受け取りましたね。また、全般的に流れを説明すれば、サーバ側で先に「9999」ポートで「listen」の状態でクライアントを待ちます。その後でクライアントはロカールの「9999」ポートで接続します。その時、サーバがクライアントに「hello world」と言う「11bytes]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/67.html</guid><pubDate>Mon, 16 Sep 2019 23:46:02 +0900</pubDate></item><item><title>[Java スタディ - 28] Reflection - Class編</title><link>https://www.nowonbun.com/68.html</link><description><![CDATA[こんにちは。明日です。このページにはreflection機能の中でクラス(class)に関して調べてみました。個人的にプログラムを勉強しながら一番驚いてプログラム実力が急成長した時期がこの「reflection」概念と勉強した時期ではないかと思いますね。「reflection機能」は要約する我々が今まで勉強したプログラム文法を全て無視してプログラム開発ができる方法ではないかと思います。例えば、クラスのインスタンスを生成する時に必ず「new」を使わなければならないとか「private」のアクセス修飾子は外部で接近ができないかなどを無視して作られます。つまり、クラスを「new」ではなくてもインスタンス生成する方法があるし、「private」のメンバー変数でもデータを取得、入力ができる意味ですね。もちろん、できるということで無分別な文法で作ればプログラムはすぐメッチャクチャになりますね。それで個人的な考えは「reflection」をよく使えるようには「standard code style」と「design pattern」を守りながら実装しないとその威力が発揮しないと思います。「reflection」は「java」言語だけではなく、「c#」やスクリプトの「python」、「php」、「javascript」もあるので比較しながら勉強するのも良いと思います。それでは「reflection」の「class」に関して紹介します。結果は「hello world」が出ました。またclassのタイプを持つ「newinstance」関数を呼ぶことではなく、「string」タイプの名でも宣言ができます。上の例をみれば、「class.forname」を利用してクラス名でタイプを持ってきます。今は同じパッケージなのでパッケージ宣言が要らないですが、実はフルネームでしなければならないです。これからコンストラクタが「private」タイプの場合に呼出す方法に関して調べます。「reflection」機能で重要なことは「string」形式で外部からクラス名を受け取ってクラスを宣言すること、「private」タイプでもコンストラクタを呼び出せることです。「string」形式で動けるというのはデザインパタンでインターフリーターと関係があり、privateとは生成パタンと関係がありますね。link - 作成中 [design pattern]]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/68.html</guid><pubDate>Tue, 17 Sep 2019 20:22:47 +0900</pubDate></item><item><title>[Java スタディ - 29] Reflection - Method編</title><link>https://www.nowonbun.com/69.html</link><description><![CDATA[こんにちは。明日です。このページにはreflection機能の中でメソッド(method)に関して調べてみました。前述で「java」の「reflection」のクラスに関して説明しました。そこでコンストラクタが「private」になっていっても呼出しができるし、「string」でクラスを探し、呼出しもできました。メソッド編でも似ているな形で使用します。まず、「string」式で関数を検索することです。上の例を見れば「node」クラスを宣言して「getmethod」関数で「print」関数を探します。後「invoke」関数にインスタンスを入れ、実行します。そして「private」の関数を実行します。上の例をみれば、「private」タイプの関数を探すようには「getmethod」ではなく、「getdeclalredmethod」で探しますね。それを検索されると接近設定を「true」に変換して「invoke」で実行します。上の例では関数でパラメータが付いているので、検索する時にパラメータタイプは「string」で「invoke」をする時にも実際にデータを入れます。結果はそのパラメータがコンソールで出力しますね。次は「reflection」のメソッドで応用部分ですが、同じ名の関数があるクラスたちを集まって実行する方法です。実は「interface」で抽象してすることが原則ですが、実務では「interface」で結ばない場合もあるので、様々で使える方法です。上の結果は同然だと思いますね。node1のクラスとnode2のクラスを同じインタフェースで派生して呼出すのは当たり前だと思います。とはいえ、node1のクラスとnode2のクラスがインタフェースを継承しなかった場合はどうでしょう。別のクラスなので、listで指定クラス自体からできないですね。違いました。「object」タイプで結べますね。上のみれば、eclipseでエラーが発生しました。なぜなら、「object」タイプは「print」関数がないからです。それを「reflection」を利用して関係性がなくても呼び出せます。上の例をみれば、各オブジェクトからクラスタイプを持って来て「getmethod」で関数を探します。探す時には「string」タイプでできるので「print」ということが掛けばメソッドを抽出ができます。そのことで「invoke」関数で実行すれば]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/69.html</guid><pubDate>Wed, 18 Sep 2019 20:03:03 +0900</pubDate></item><item><title>[Java スタディ - 30] Reflection - Variable編</title><link>https://www.nowonbun.com/70.html</link><description><![CDATA[こんにちは。明月です。このページにはreflection機能の中で変数(variable)に関して調べてみました。前述、クラス(class)とメソッド(method)に関して調べてみました。link - 作成中link - 作成中さて、reflectionではクラスとメソッドは様々なパターンを作るようによく使うことですが、変数はあまり使わないですね。なぜなら、クラス中でメンバー変数はその目的があるし、データを入れ変わったりするとクラス処理がエラーなる可能性があるのでです。でも、その必要性が全然ないことではないかと疑問になりますが、クラスの流れでテストする時にデバッグのように変数のデータを確認する時や最近、mvcモデルでdi(依存性注入)概念があり、外部で変数にクラスのファクトリーパターンでインスタンスを刺し入れる処理で使えます。上の例をみればメンバ変数が「private」タイプでも「data」の値を「100」に変わりました。「reflection」と場合はプログラム文法をメッチャクチャになれることができますね。では「reflection」はパフォーマンス的に遅くなる可能性があるし、無分別に使うとコードパターンや設計があっというまでめちゃくちゃになるのでデザインパターンやソース標準なので守りながら使わなければならないと思います。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/70.html</guid><pubDate>Thu, 19 Sep 2019 20:20:35 +0900</pubDate></item><item><title>[Java スタディ - 31] Reflection - Annotation編</title><link>https://www.nowonbun.com/71.html</link><description><![CDATA[こんにちは。明月です。このページではこのページにはreflection機能の中でアノテーション(annotation)に関して調べてみました。前述でアノテーションに関して説明した時があります。link - [java スタディ - 26] アノテーション(annotation) その時にアノテーションではただ、クラスやメソッドや変数などのメタデータだと言いましたが、実はアノテーションはreflectionで入るとデータ初期設定、メソッドを探しの里程表だと思います。上の例をみれば、クラスのメソッドを全て取得してアノテーションがあるかどうかであるなら「invoke」で実行します。なので結果は「method1」、「method3」は出力するし、「method2」の場合は出力しないですね。上の例を見れば「main」で「example」クラスを割当てクラスの中の「node」変数にデータを入れるところがありません。当たり前で「node」変数は「null」と予想します。でも「exec」で「node」クラスの「print」メソッドを呼出す時、「exception」が発生しませんでした。その理由は「main」関数で「reflection」機能を使ってアノテーションに書いている「クラス」名で割当てしたからのです。上の例が依存性注入の概念ですね。「reflection」機能はデザインパターンと合わせることになると素晴らしく綺麗なソースに作られるので、デザインパターンも含めて熟知しなければならないと思います。]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/71.html</guid><pubDate>Fri, 20 Sep 2019 22:35:47 +0900</pubDate></item><item><title>[Java スタディ - 32] Mavenをインストール、使用方法、そしてeclipseに連結する方法</title><link>https://www.nowonbun.com/72.html</link><description><![CDATA[こんにちは。明月です。このページはmavenをインストール、使用方法、そしてeclipseに連結する方法について調べてみました。以前、約10年前でもプロジェクトを構成する時に必要なライブラリあればインタネットで検索してダウンロードして使いました。なので、ライブラリバージョン管理もできないし、正常なライブラリ(ライブラリにウイルスを入れて配布する人もいました。)かどうかも検証することが簡単ではありません。また、コミュニティーが各々にあるので、説明が統一もできないし、ライブラリの共有もバラバラでした。率直にライブラリより実際に作って使うほうが楽な部分もありましたよね。しかし、プロジェクトのサイズが段々大きくなって、現在はオープンライブラリがなければプロジェクト運用もできないようにサイズが大きくなりました。それで、最近はオープンライブラリを管理するツールとライブラリを集まったコミュニティーのrepositoryがあります。javaではライブラリ管理ツールをmavenと言います。(c＃ならnugetと言うし、phpはcomposer、pythonはpipがあります。)link - https://maven.apache.orgmavenをインストールするように上のサイトに接続してダウンロードします。適当なところで圧縮を解凍します。そして「cmd」で当該なフォルダに行って「bin」フォルダで「mvc -version」を確認します。その後で環境変数の設定をします。環境設定を設定した後、「cmd」に行ってもう一回に確認します。maven設定は完了しました。mavenを「eclipse」に設定します。「eclipse」の「preferences」タブに移動します。そして「maven」をインストールしたフォルダを設定します。これから「eclipse」で「maven」プロジェクトを生成します。先は一般プロジェクトで生成しますね。「maven」プロジェクトに変換します。そうしたら「pom.xml」が生成されます。「maven」のテストのため、「gson」を追加します。pom.xmlを作成してライブラリをアップデータします。テストのため、ソースを作成します。結果は「json」タイプで「string」を「node」クラスで変換をしました。その意味は「gson」ライブラリがちゃんと動いてる状況ですね。なので、「eclipse」か]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/72.html</guid><pubDate>Tue, 24 Sep 2019 00:20:10 +0900</pubDate></item><item><title>[Java スタディ - 33] 「Eclipse」でトムキャット(tomcat)を設定する方法</title><link>https://www.nowonbun.com/73.html</link><description><![CDATA[こんにちは。明月です。このページでは「eclipse」でトムキャット(tomcat)を設定する方法に関して調べてみました。トムキャットはクライアント(browser)と通信しながらウェブページ情報(html)を転送するウェブサーバ(web server)とウェブページを動的に作られるウェブコンテナ(サーブレットコンテナ)を搭載しているアプリケーションサーバ(was)の機能を持っているオープンソースプログラムです。基本的にapache財団で提供するので無料だし、強力な機能を持っているサーバです。「eclipse」環境でjavaを利用してウェブ(jsp)を開発するために一応「eclipse」でトムキャットが設定されていなければならないです。そうするとトムキャットホムページに行ってダウンロードします。link - https://tomcat.apache.org/download-80.cgi「eclipse」で使うものなので「installer」ではなく、「zip」になっている圧縮ファイルでダウンロードします。そして、適当なところで圧縮を解凍してもよいですが、管理のため「eclipse」がインストールされたところで解凍します。トムキャットの解凍が終わったら、「eclipse」を起動して新しいプロジェクトを生成します。そしてプロジェクトウィザードはサーバを選択しますね。そしてトムキャットバージョンと合わせるリストを選択します。その後、トムキャットを解凍したフォルダを選択します。プロジェクトエクスプローラに「server」のプロジェクトがあり、トムキャット設定情報があれば設定完了になったことです。トムキャット設定を変わるようには下記のserverタブをクリックしてサーバを選択します。概要(overview)のウィンドウがでますが、他の設定は触ることがないし、「port」設定と「timout」設定だけ仕様によって設定が変わる可能性がありますね。タイムアウト設定はコンパイルする時にサーバが起動待ちですがコンパイル時間がかかることで設定時間より超えるとサーバが落ちることです。pc仕様が遅いと思うとこのタイムアウト設定をしなければならないです。しなければ、起動する時に45秒タイムアウトでトムキャットが起動を止まります。ポートの場合はトムキャットの基本ポートは「8080」です。どこかでそのポートを使っているアプリケーショ]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/73.html</guid><pubDate>Tue, 24 Sep 2019 19:36:48 +0900</pubDate></item><item><title>[Java スタディ - 33] Servletを作成方法(Eclipse)</title><link>https://www.nowonbun.com/74.html</link><description><![CDATA[こんにちは。明月です。このページでは「java」を利用してウェブサービス(jsp servlet)を作成する方法について調べて見ました。「java」でウェブプログラミングすると、「struts」や「spring」などに関して様々に話を聞こえるですね。実は「struts」や「spring」はウェブプログラミングのフレームワークです。それがウェブプラットフォームではありません。「java」のウェブプラットフォームに関して話すると基本的に「java servlet」だといいます。link - https://ko.wikipedia.org/wiki/こんな具体的な話は要らなく、先に「eclipse」でウェブサーブレットを生成してブラウザで「hello world」まで表示する方法に関して記述します。サーブレットを作るように先に「eclipse」でトムキャットがインストールされなければならないです。link - [java スタディ - 33] 「eclipse」でトムキャット(tomcat)を設定する方法先に「new project」-&amp;gt; 「other」を選択します。その中で「web」-&amp;gt;「dynamic web project」を選択して「next」ボタンを押下します。そしてプロジェクト名前とトムキャット設定、「module version」が合っているかを確認して「finish」ボタンを押下します。※参考で「eclipse」をエンタプライズバージョンでインストールしないとウェブサーブレット生成が上手くできない可能性があります。基本eclipseの場合は上のイメージらしく動作しません。link - [java スタディ - 1] javaとは？、javaインストール、eclipseインストール プロジェクトを生成した後、「web.xml」を確認します。もし、「web.xml」がない場合は下記の方法で生成するとよいです。実は以前のバージョンはいつも生成しましたが、いつから「web.xml」が自動に生成しないですね。生成したら基本的な内容を確認します。「welcome-file-list」タグだけありますが、そのタグは基本「root」ページの設定ですね。私の場合は「index.jsp」だけ設定します。これから「index.jsp」を作成してウェブブラウザで「hello world」が]]></description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/74.html</guid><pubDate>Wed, 25 Sep 2019 20:01:02 +0900</pubDate></item><item><title>Open source</title><link>https://www.nowonbun.com/opensource.html</link><description>Open source</description><category>Open source</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/opensource.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Devlopment note / Javascript, Jquery, Css</title><link>https://www.nowonbun.com/dev_javascript.html</link><description>Devlopment note / Javascript, Jquery, Css</description><category>Devlopment note / Javascript, Jquery, Css</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_javascript.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / Javascript, Jquery, Css</title><link>https://www.nowonbun.com/study_javascript.html</link><description>Study / Javascript, Jquery, Css</description><category>Study / Javascript, Jquery, Css</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_javascript.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Project</title><link>https://www.nowonbun.com/project.html</link><description>Project</description><category>Project</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/project.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Devlopment note / Window</title><link>https://www.nowonbun.com/dev_window.html</link><description>Devlopment note / Window</description><category>Devlopment note / Window</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_window.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / PHP</title><link>https://www.nowonbun.com/study_php.html</link><description>Study / PHP</description><category>Study / PHP</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_php.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Experience</title><link>https://www.nowonbun.com/experience.html</link><description>Experience</description><category>Experience</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/experience.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Devlopment note / Linux</title><link>https://www.nowonbun.com/dev_linux.html</link><description>Devlopment note / Linux</description><category>Devlopment note / Linux</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_linux.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / Python</title><link>https://www.nowonbun.com/study_python.html</link><description>Study / Python</description><category>Study / Python</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_python.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Other</title><link>https://www.nowonbun.com/other.html</link><description>Other</description><category>Other</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/other.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Welcome</title><link>https://www.nowonbun.com/1.html</link><description><![CDATA[準備中]]></description><category>Other</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/1.html</guid><pubDate>Mon, 1 Jul 2019 01:42:41 +0900</pubDate></item><item><title>Devlopment note / Etc.</title><link>https://www.nowonbun.com/dev_etc.html</link><description>Devlopment note / Etc.</description><category>Devlopment note / Etc.</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_etc.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / Database</title><link>https://www.nowonbun.com/study_database.html</link><description>Study / Database</description><category>Study / Database</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_database.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / Design pattern</title><link>https://www.nowonbun.com/study_design_pattern.html</link><description>Study / Design pattern</description><category>Study / Design pattern</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_design_pattern.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item><item><title>Study / Algorithm</title><link>https://www.nowonbun.com/study_algorithm.html</link><description>Study / Algorithm</description><category>Study / Algorithm</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_algorithm.html</guid><pubDate>Wed, 25 Sep 2019 20:01:15 +0900</pubDate></item></channel></rss>