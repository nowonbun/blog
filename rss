<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/" xmlns:activity="http://activitystrea.ms/spec/1.0/" ><channel><title>明月の開発ストーリ</title><link>https://www.nowonbun.com</link><description>Test</description><language>ja</language><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate><generator>nowonbun@gmail.com</generator><managingEditor>nowonbun@gmail.com</managingEditor><webMaster>nowonbun@gmail.com</webMaster><item><title>明月の開発ストーリ</title><link>https://www.nowonbun.com/index.html</link><description>明月の開発ストーリ</description><category>明月の開発ストーリ</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/index.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Devlopment note / C, C++, MFC</title><link>https://www.nowonbun.com/dev_clanguage.html</link><description>Devlopment note / C, C++, MFC</description><category>Devlopment note / C, C++, MFC</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_clanguage.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / C, C++, MFC</title><link>https://www.nowonbun.com/study_clanguage.html</link><description>Study / C, C++, MFC</description><category>Study / C, C++, MFC</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_clanguage.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Devlopment note / C#</title><link>https://www.nowonbun.com/dev_csharp.html</link><description>Devlopment note / C#</description><category>Devlopment note / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_csharp.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / C#</title><link>https://www.nowonbun.com/study_csharp.html</link><description>Study / C#</description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_csharp.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>[C# スタディ - 1] C#とは？</title><link>https://www.nowonbun.com/2.html</link><description><![CDATA[こんにちは。明月です。今日はc#を勉強する前にc#について説明します。プログラム言語はc、c++、java、c#など様々な言語があります。言語の誕生時期はc言語が一番早いし、次はmicrosoftからウィンドウ開発をしやすくするc++（mfc）、プログラムについて少しでも勉強したら聞いたかも知らない言語のjava、その次がこれから勉強しようと思うc#の順になります。誕生時期を見るとc#は上の4つの言語の中で最後になりますが、最後に誕生したから一番いい言語では思わられませんね。プログラム言語は各特徴があり、開発状況のたびに使う方法が違うと思います。各言語について簡単に説明するとc言語の場合はハードウェア系とos系(カーネル)、ドライバー系で主に使うし、c++(mfc)はグラフィック系またはc#で実装が大変な部分、c#よりメモリ管理が厳しい環境で使いますね。javaの場合はネットワークのウェブ系、アンドロイドモバイル系で使うし、c#はネットワークサーバクライアントウィンドウ（cs)系でよく使います。機能として使うところはそのとおりですが、プロジェクトの予算、環境などの影響でウィンドウプログラムをjavaで開発するし、c++とc#を混在して使う時もあります。c#は.net frameworkの上で動いています。.netframeworkはウィンドウosしかないのでlinuxやウィンドウ以外の環境では開発ができません。現在(2016年5月).netframeworkのバージョンは4.6まで発表してc#のバージョンは6.0まで発表しています。c#のバージョン別で説明すると下記のとおりになります。          c# バージョン    重要機能              c# 2.0               c# generics      anonymous method (匿名メソッド)      nullable type      partial type      c# yieldキーワード      delegateについてcovariance/contravariance                   c# 3.0               lambda expression (ラムダ)      anonymous type (匿名タイプ)      extension method ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/2.html</guid><pubDate>Wed, 3 Jul 2019 00:00:21 +0900</pubDate></item><item><title>[C# スタディ - 2] IDE(統合開発環境)のインストール</title><link>https://www.nowonbun.com/3.html</link><description><![CDATA[こんにちは。明月です。今日はc#開発環境を構築します。c#を開発するようにはmicrosoftのvisual studioが必要です。visual studioは昔には高いツールだったんでしたが、最近はcommunityバージョンで無料で提供しています。url - visual studio download現在(2019年7月)は上のurlで接続して下記の形のホームページが出ます。実際にホームページを見ると様々なダウンロードボタンがありますが我々は「community」バージョンをダウンロードして勉強します。さて、インストールファイルをダウンロードが完了し実行するとインストールが始まりますね。インストールが完了したらvisualstudioを実行してみましょう。始めに実行すると「初期のemailアドレスを入力して登録してください。」という意味のメッセージが出ます。既存にmicrosoftのホームページに接続してログインしたemailのアドレスを入力してemailから認証番号をもらいます。もし、登録してないならmicrosoftホームページに行って登録してください。(私の場合は既存に登録したので手続きは省略します。)認証番号登録が完了すると下記のとおりにメッセージが出て次の段階に超えます。最終に上の画面が出ますとインストールが成功です。ここまでc#の開発準備を完了しました。次の投稿ではc#のプログラム基本構造を勉強し、「helloworld」を出力しましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/3.html</guid><pubDate>Wed, 3 Jul 2019 00:00:32 +0900</pubDate></item><item><title>[C# スタディ - 3]  基本構造と「Hello world」</title><link>https://www.nowonbun.com/4.html</link><description><![CDATA[こんにちは。明月です。今日からc#の基本文法について勉強します。それならvisualstudioを起動して新しいプロジェクト(ctrl+shift+n)を生成しましょう。そうすれば下記とおりに画面が出ますね。テンプレート項目で「コンソールアプリケーション」というリストを選択します。その後で「名前」項目にプロジェクト名を書き込みます。(私の場合はhelloworldということに書き込みました。)そして「ok」ボタンを押下して新しいプロジェクトを生成します。新しいプロジェクトが開けると基本的なプログラムの構造は準備しています。次の投稿から具体的に勉強するので、今日は一旦「namespace」の中で「class」の中で「main」のメソッドにコードを書き込んで作業します。これから「helloworld」を出力しましょう。c#でコンソール関連クラスは「console」のクラスです。その中で出力するメソッドは「write」あるいは「writeline」のメソッドを利用します。その通りにコーディングをすると下記みたいになります。ソースコーディングが作成できたら「f5」キーを押下してデバックをしましょう。結果は予想とおりに得ました。ちなみにコーディングについて説明します。コーディング内容を見ると行の最後にセミコロン(;)があります。それはブロックを開閉表示(｛、｝)以外にソース命令語が終了する時にセミコロンをつけることでコーディング約束が決めています。初心者の場合はセミコロンの漏れでコンパイルエラーが発生する時があるのでご注意してください。また、上のソースを見ると最後に「console.writeline(“press any key…”); consolre.readlist();」の部分があります。その部分を消して実行(f5)するとあっというまで結果コンソールが開いて閉じます。それならソース実行結果を確認できないのでしばらくにはソースを組む時にその2行ソースを追加しましょう。ここまで「helloworld」を出力しましたが、考えよりプログラムが簡単に作成できましたよね。c#の利点は初心者も簡単にしやすくプログラムを作成できるし開発進入壁が低いことです。でもどんな言語でも開発が複雑になると言語の特徴を100％に活かせる必要がありますので勉強が必要です。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/4.html</guid><pubDate>Wed, 3 Jul 2019 00:00:53 +0900</pubDate></item><item><title>[C# スタディ - 4] コメント</title><link>https://www.nowonbun.com/5.html</link><description><![CDATA[こんにちは。明月です。前の投稿でプログラムの基本構造について勉強しました。そう見るとアセンブラーよりは読みやすいですが、人間が読みやすいには言えません。簡単なプログラムなら解読するのが大変ではないけど、複雑度が上がるとコードを読むのがだんだん大変になると思いますね。それでプログラムをコーディング式ではなく、人が読みやすい方法でコメントがあります。プログラム中でコメントを付ける方法は３つがあります。改行タイプのコメントです。使用方法は改行頭に「//」を付けて使います。次はブロックタイプのコメントがあります。使用方法は下記とおりです。ブロックタイプのコメントは重複処理ができないので、使用するときに注意が必要です。最後にxmlコメントがあります。xmlコメントはプロジェクトが終了する時にxmlコメントでマニュアルを生成できるコメントです。javaの場合はjavadocと同じコメントです。(でも実際にxmlコメントでマニュアルまで生成しません。機能としてはありますが…)使用方法はclass頭あるいはmethod頭で「///」を付けて使います。xmlコメントの場合各タグがあって、タグ別で説明する区切りがあります。下記の表を参考してください。          xmlコメントタグ    説明              summary    形式あるいは形式メンバ設定          remarks    詳細な説明          para    remarksの追加説明          value    プロパティの説明          example    使用例          list    リストとテーブル生成          code    何行目のコードで表示する時に使用          see    テキスト内部のリンク指定          seealso    参考部分に表せるテキスト指定          exception    例外説明          permision    接近権限説明          param    メソッドのパラメター説明          return    返却値を説明          c    説明中で含めているコード      プロジェクトを進める時に簡単なプログラムは一人で作成できますが、普通のプロジェクトならチームを組んで進めると思]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/5.html</guid><pubDate>Wed, 3 Jul 2019 00:01:13 +0900</pubDate></item><item><title>[C# スタディ - 5] データタイプとリテラル(literal)、 Nullable</title><link>https://www.nowonbun.com/6.html</link><description><![CDATA[こんにちは。明月です。今日はデータタイプとリテラル(literal)、nullableについて勉強します。とりあえず、データタイプについて説明します。我々がパソコンでプログラムを作ることは大きい計算機を作ることだと思うと良いです。利用の目的は差異があると思いますが、ゲーム、デザインツール、バッチプログラムなども内部を見ると結局に数の計算になっています。人間は整数、実数の区別せずに計算ができますが、パソコンの場合は整数、実数、文字が完全に分けてあります。それをデータタイプと命名してメモリを宣言する時に定義します。そうするとデータタイプ種類と説明に下記に記述します。          c#データタイプ    .netデータタイプ    説明              bool    system.boolean    true or false                      byte                system.byte                8ビットunsigned integer                                        sbyte                system.sbyte                8ビットsigned integer                                        short                system.int16                16ビットsigned integer                                        int                system.int32                32ビットsigned integer                                        long                system.int64                64ビットsigned integer                                        ushort                system.uint16                16ビットunsigned integer                ]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/6.html</guid><pubDate>Thu, 4 Jul 2019 00:20:32 +0900</pubDate></item><item><title>[C# スタディ - 6] 変数と定数</title><link>https://www.nowonbun.com/7.html</link><description><![CDATA[こんにちは。明月です。今日は変数と定数、すなわちメモリにデータを格納する場所について勉強します。プログラムを作成して、様々な数を計算すると結果の値を何処か格納して保管する必要があります。そのため、プログラムを下記の形式で作成しなければならないです。上のことを見ると変数はメモリに格納する場所になることは分かりました。それならプログラムの設計によってデータが変わらないデータもある可能性がありますね。その時に変数宣言する仕方で「const」をつけると変わらない変数、すなわち定数になります。変数の場合は宣言する場所によって変数の使用方法が変わります。メンバ変数の場合はクラスが生成する時に生成されてクラスが解除する時に解除します。ローカルの場合はローカルブロックが閉じる時に解除します。この変数のcycleはクラスを勉強する時に詳しく勉強するので、今は使う仕方だけちゃんと覚えて行きましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/7.html</guid><pubDate>Thu, 4 Jul 2019 00:13:06 +0900</pubDate></item><item><title>[C# スタディ - 7] 配列とリスト(List)、 そしてArrayList</title><link>https://www.nowonbun.com/8.html</link><description><![CDATA[こんにちは。明月です。今日は配列について勉強します。我々がプログラムを作成すれば変数宣言をたくさんすると思います。例えば、１ヶ月のスケジュールのプログラムを作成すると思えば１ヶ月間のデータを格納する変数が必要だと思います。さらに考えると、１ヶ月ではなく１年分だと思うと365個の変数が必要です。そうするとソース管理が大変になると思います。それでその場合は同じタイプの変数を結んで配列に作ります。配列の仕様方法については下記のとおりになります。上の列例を見ると整数タイプの「int」系で「test」の変数に10個を宣言すると意味になります。配列は「0」番から始まって10個なので、「9」番までメモリに宣言されます。もし「10」番以上にデータを入れるとエラーになります。こんなみたいに配列を使う場合、何個を使うかを決めて宣言します。プログラム設計によって違うと思いますが、プログラムで変数を何個を使うか知らないケースもあります。その場合にできるほど、大きく配列を宣言するのはできないので、動的の配列、すなわちリストを使います。c#ではlistはクラス形態なので仕様方法は、下記とおりになります。配列を比べてリストは個数宣言が必要なく使います。でも今回は個数でけではなくデータタイプも知らないケースがあります。その場合はlist&amp;lt;object&amp;gt;を使っても良いですが、クラスとしてはarraylistがあります。今まで配列、リスト(list)、arraylistについて勉強しました。機能だけ見るとarraylistが使いやすいし、配列は厳しそうですね。それならarraylistだけ使えばいいと思いになりますが、配列とarraylistの差は利便性だけではなく、性能(パフォーマンス)も差があります。リスト、arraylistはクラスタイプなので構造体の配列より遅くなります。(配列リストの場合は再宣言、連携リストの場合は検索)データ処理量が少なければ何でも使っても構わないですが、大量のデータの場合はどんなタイプを使うかのことで実行速度の差が発生します。それで正確に使うのがプログラム品質のため良いと思います。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/8.html</guid><pubDate>Fri, 5 Jul 2019 00:14:08 +0900</pubDate></item><item><title>[C# スタディ - 8] 演算子</title><link>https://www.nowonbun.com/9.html</link><description><![CDATA[こんにちは。明月です。今日はプログラムの演算子について勉強します。プログラムは演算子が数学らしい数式の演算子があるし、その以外に論理演算子、条件演算子などもあります。演算子に関することは下記の表と例を参考して詳しく説明します。          演算子タイプ                演算子                                例                                   数式演算子                +, -, *, /, %                                int a = (x + y - z) * (b / c) % d;                                                        割当演算子                =, +=, -=, *=, /=, %=                int a = 100;sum += a;                                        増加/減少演算子                ++, --                int i = 1;i++;                                        論理演算子                &amp;amp;&amp;amp; (and), || (or), ! (not)                if ((a &amp;gt; 1 &amp;amp;&amp;amp; b &amp;lt; 0) || c == 1 || !d)                                        関係/比較演算子                &amp;lt;, &amp;gt;, ==, !=, &amp;gt;=, &amp;lt;=                if (a &amp;lt;= b)                                        ビット演算子                &amp;amp; (and), | (or), ^ (xor)                byte a=7;byte b=(a &amp;amp]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/9.html</guid><pubDate>Fri, 5 Jul 2019 00:13:41 +0900</pubDate></item><item><title>[C# スタディ - 9] 制御文 - 分岐 (if, switch〜case, goto)</title><link>https://www.nowonbun.com/10.html</link><description><![CDATA[こんにちは。明月です。今日からは制御文を勉強します。プログラムの制御文はc#だけではなく、c言語やjavaと同じです。そしてその中で制御文は大きく３つの形で分けます。プログラムの流れで何の項目を選んで流すかを決める分岐制御、特定ブロックの流れを繰り返すループ、ループの流れを分岐するループ分岐があります。その中で今日は分岐(if, switch〜case, goto)を勉強します。if〜else if〜else文if〜else if〜else文は真、偽によって処理する制御文です。上の例を説明すると変数「a」の値は「5」なので一つ目の分岐では「else if(a &amp;gt; 0)」を通って「console.writeline(&quot;文２&quot;);」になります。次の変数「b」の場合は「true」だから「if」の条件を満たします。それで「console.writeline(&quot;文４&quot;);」に実行されます。最後も「if」条件を満たすので「console.writeline(&quot;文６&quot;);」を実行します。switch文「switch」は制御条件値が間に合うところを処理するマルチ制御文です。上の例を見ると変数「a」は「5」の値が格納されています。それで「switch」の「case 5」を通って「console.writeline(&quot;文１&quot;);」を実行します。c#の「switch」文は他の言語と違うところがあります。それはc++、javaの場合は「switch〜case」に行って「break」を付けないことができます。「break」がなければ次の文に実行する処理になるがc#の場合はこの「case」の後に「break」が必須キーワードなので「break」を利用して次の段階に行く処理がありません。goto文「goto」文はラベルの部分に強制的に移動する制御文です。そして「goto」文はプログラムの中で使わない制御文です。なぜならプログラムの中で「goto」文が多いなら性能(パフォーマンス)が悪くなるし、後でソース管理が大変になるからです。参考してください。上の例を見ると実行中で「goto test」文にあうと「test」ラベルに移動ます。今日は制御文の分岐に関して勉強しました。その中で「if」の場合はプログラムで一番多く使う制御なのでよく覚えて行きまし]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/10.html</guid><pubDate>Sat, 6 Jul 2019 00:57:29 +0900</pubDate></item><item><title>[C# スタディ - 10] 制御文 - ループ(for, while, do〜while, foreach)</title><link>https://www.nowonbun.com/11.html</link><description><![CDATA[こんにちは。明月です。前の投稿で分岐に関して勉強しました。今日は引き続いて制御文のループに関して勉強します。ループは単語のいみとおりに繰り返す処理ということです。ループの種類は「for」、「while」、「do〜while」、「foreach」の４つがあります。for 文「for」文は初期化より終了条件が偽になるまで増減値を変換しながら繰り返す制御文です。例を見ると「i」の変数に「0」の値を初期して「i &amp;lt; 10」の条件をチェックします。結果が「真」になるので「console.writeline(i);」を実行します。文の処理が終わって増減式に行って「i」の値を増加(i = 1)します。また「i &amp;lt; 10」の条件をチェックしてまた「真」になるので「console.writelist(i);」を実行します。そのままに「i」の値が「10」になるまで繰り返します。while 文「while」文は条件式が真になる間に繰り返す制御文です。「while」文は「for」文の初期式と増減式が除いてるものです。上の例をみると「while」文には別に増減式がないので「i++」を除いたら無限ループ(ループが終わらない状態)になる可能性があるので気をつけてください。do〜while 文「do〜while」文は「while」と似ています。でも「while」は初めから条件式をチェックして繰り返しますが「do〜while」文は１回実行した後から条件式をチェックします。「do〜while」文は条件をチェックして文を実行することではなく文を実行してから条件を繰り返すかをチェックするものです。上の例を見るとwhileの場合は「i &amp;lt; 0」の条件に満たさないので「console.writeline(&quot;while&quot; + i);」が実行されなかったです。でも「do〜while」文の場合は「console.writeline(&quot;do while &quot; + i);」を１回に実行した後に条件文をチェックするので「do while 0」が出力されました。実際にプロジェクトする時に「do〜while」文は一般ループと流れが違うから判断がつかないことが多く発生します。それで「do〜while」文を使うのはお勧めしません。foreach 文配列またはリストの個数のほどに繰り返します]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/11.html</guid><pubDate>Sat, 6 Jul 2019 01:07:33 +0900</pubDate></item><item><title>[C# スタディ - 11] 制御文 - ループ分岐(break, continue)</title><link>https://www.nowonbun.com/12.html</link><description><![CDATA[こんにちは。明月です。今日は制御文の最後のループ分岐に関して勉強します。我々がプログラムロジックを作成すると無限ループを作る時があります。でも本当に無限になるとプログラムが終わらないのでループの中で止まること、すなわち分岐ループが必要です。break 文「break」はループ制御を抜け出す時に使う制御文です。上の式を見ると「while」文は条件式がいつも「真」(true)になるので無限ループになります。でも、文の中で「if」によって「i」が「10」になると「break」文を呼ばれて無限ループから抜け出します。ループを強制的に抜け出すのは「break」になります。でも抜け出すことではなく、ループ文を終わらせずに次のインデックスに行くケースもあります。contineu 文「continue」はループ制御の次のインデックスに飛び超える制御です。上の例を見ると別に「break」、「continue」を使わなくても「if」文だけで処理ができそうですね。でも「break」、「continue」をよく使うとソースが綺麗になるのでループの中には状態をよくみて使うほうが良いと思います。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/12.html</guid><pubDate>Sun, 7 Jul 2019 22:56:17 +0900</pubDate></item><item><title>[C# スタディ - 12] メソッド(関数)とvoid型</title><link>https://www.nowonbun.com/13.html</link><description><![CDATA[こんにちは。明月です。今日はc#のメソッドに関して勉強します。メソッドあるいは関数と呼ばれる機能は数学の関数(function)と同じ意味です。すなわち、関数に任意の数を入れると関数の式によって計算をされる数の値がでることになります。それなら、プログラムの関数の使用方法は下記のとおりです。上の例で「static」のキーワードはとりあえず無視しましょう。例を説明すると「exammethod」、「exammethod」の関数があります。「exammethod」の場合は「10」のデータを入れると「10」倍になって「100」の値が返却すると思います。「exammethod2」の場合は「10」、「20」のデータを入れると２つのデータが足すので「30」のデータが返却すると思いますね。メソッド(関数)は上の形態が基本ですが返却値が１つではなく２つ以上になるあるいはパラメタの個数が動的になる場合もあります。上の関数の場合はパラメタ「b」は「a」の値の商、「c」には「a」の値の余のデータが返却し、メソッド(関数)は余が「0」の場合は「true」、その以外は「false」を返却します。パラメタ個数が可変の場合は下記とおりです。上の例はパラメタで受け取ったデータをすべて合計する関数です。void今まで我々は関数の返却値があるように作成しました。でも逆に返却値が必要ではない場合もありますね。例えも上の返却値が２つ以上の例を見ると関数返却値は余が「0」かどうかの値を返却しました。でも、「0」かどうかの値は要らずに商と余だけ返却したい時があると思いますね。その場合は返却値に「void」のキーワードを書いて「返却をしない」というを明示します。今までメソッド(関数)の方法にかんして勉強しました。メソッド(関数)のことは数学のファンクションみたいに結果値に置換ができます。それなら数学の数列という数の並びがあります。たとえば「1」から「10」の合計はどうすればいうと数式に変換すると「1+2+3+4+5+6+7+8+9+10」になります。「10」の「1」を足すの等差数列を分析すると「9」の「1」を足すの等差数列+「10」に表現ができますね。すなわち「n」の「1」を足すの等差数列は(n-1)の「1」を足すの等差数列に表現ができます。そのとおりに「1」の等差数列は「1」になりますね。それをプログラムで実装すると下記とおりです。上の例を見ると「su]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/13.html</guid><pubDate>Sun, 7 Jul 2019 23:14:29 +0900</pubDate></item><item><title>[C# スタディ - 13] アクセス修飾子(public, private, protected)</title><link>https://www.nowonbun.com/14.html</link><description><![CDATA[こんにちは。明月です。今日はアクセス修飾子について勉強します。アクセス修飾子アクセス修飾子はoopの基本特性のカプセル化と関係があります。次の投稿のクラスについて勉強する時に詳しく説明すると思いますが、「c#」プログラミングはoop(オブジェクト指向プログラム)と呼びます。そしてoopの最小の単位のオブジェクトはクラスです。そしてクラスの中には様々なデータがあります。データを定義する時は見せても良いデータがありますが、隠さなければならないデータもあります。それを区別しながら作成する方をカプセル化と言います。そうすると、アクセス修飾子の種類は下記とおりです。          アクセス修飾子    内部クラス    外部クラス    派生クラス    プロジェクト              public    ○    ○    ○    ○          private    ○                      protected    ○        ○              internal    ○    ○    ○              protected internal    ○        ○          上の例は実際にそのように実装するとダメですが、アクセス修飾子の説明ために作成しました。とにかく、例を見ると「public」は変数「name」、「birth」、「year」、メソッド「setdata」が外部から見えます。逆に変数「year_birth」、「month_birth」、「day_birth」、メソッド「yearcalc」は「humen」クラスの構成より「year」を計算するためのデータなので外部から見せる必要がありません。逆に考えてすべての変数、メソッドが「public」になって外部に見せることになるとクラスの処理には問題がないですが、プロジェクト管理するためには深刻な問題が発生する可能性があります。なぜなら、ただ「name」、「birth」、「year」だけ見える時はクラスを知らない方が見てもユーザと関係があるクラスだと思いますが、すべてのデータが開けると意味がわからなくなります。また、上の例は簡単なので処理問題では発生しないけれども複雑のプログラムなら処理中で計算データを変更させると結果データが可笑しく出る可能性があることです。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/14.html</guid><pubDate>Mon, 8 Jul 2019 22:56:02 +0900</pubDate></item><item><title>[C# スタディ - 14] プロパティ(property)</title><link>https://www.nowonbun.com/15.html</link><description><![CDATA[こんにちは。明月です。今日はプロパティについて勉強します。前の投稿に「変数」について勉強しましたが、その中でメンバ変数が今日勉強するプロパティと関係があります。[c# スタディ - 6] 変数と定数oop(オブジェクト指向プログラム)の特徴でカプセルがあります。クラスを宣言して使う立場ではクラスの変数とメソッドを参照制限にすることをカプセルと言います。この制限はプログラム的で実装禁止ではありませんが、コーディングの規約(プログラム実装の方法として決められた約束)によって決められています。その規約の一つがクラスの「メンバ変数は「private」にする」、すなわち外部から参照禁止になっています。そうするとメンバ変数の値は外部で取得をどうするかといえばプロパティを通って取得します。上の例の「name」が基本的に使うプロパティの構造です。変数名が小文字で書いてるものをプロパティの変数名から語頭１桁を大文字に変換して書きます。「name」のデータは外部で直接に参照できなくて、「name」のプロパティを通って取得できます。読み専用プロパティの場合は「set」部分を省略して作成します。それで「comp」プロパティは「comp」変数からデータを取得できますが、格納ができない状況になっています。応用プロパティの場合は「string」タイプのデータを受け取ります。そして文字分け関数で文字列のデータを分けます。各「year」、「month」、「day」の変数に「int」型にて変換して格納します。また、逆に外部から取得する時は「year」、「month」、「day」データを合わせて「string」タイプに変換して返却しています。外部で見るとプロパティは「birth」タイプしか見えない構造になっています。実際にプログラム実装する時はほとんど基本プロパティ型を使います。それで「.net framework 3.0」からはメンバ変数も省略が可能な形式があります。今までプロパティについて勉強しました。でも、これだけではなぜプロパティを使うかを確かに認識ができません。プロパティの場合はただカプセルの理由だけではなく、継承、抽象等oopの特徴の部分と密接な関係があります。今はインタフェースや抽象クラスの概念がない状況では説明が難しいですね。とりあえず、上の形式で使い進んで、またインタフェース、抽象クラスチャプターで詳しく勉強しましょう。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/15.html</guid><pubDate>Thu, 11 Jul 2019 23:22:56 +0900</pubDate></item><item><title>[C# スタディ - 15] クラス(class)とコンストラクタ、そしてnew(割り当て)</title><link>https://www.nowonbun.com/16.html</link><description><![CDATA[こんにちは。明月です。今日はクラスについて勉強します。プログラムを少しでも扱ったことがある方なら「クラス」について聞いたことがあると思います。クラス(class)クラスはoop(オブジェクト指向プログラム)の最小単位です。構成要素はメンバ変数、プロパティ、メソッド、イベントがあります。その中で我々は変数、プロパティ、メソッドについて勉強しました。イベントはデリゲートと関係がありまして少し後で勉強します。[c# スタディ - 6] 変数と定数[c# スタディ - 14] プロパティ(property)[c# スタディ - 12] メソッド(関数)とvoid型クラスの構成は上のとおりです。使用方法では「new」キーワードを使ってメモリに割り当て使います。new「new」キーワードは配列を宣言する時に使ったことがあります。配列を宣言する時と同様にクラスの「new」もメモリに「割り当てをします」という意味です。上の例を見ると割り当て演算子の区切りで「testclass test」「new testclass」に分けて考えて見ましょう。前の「testclass test」は変数と同様の意味でメモリアドレス(整数)が入ります。「new testclass」の場合はメモリ(heap)に「testclass」を割り当てます。上のイメージとおりにクラスが宣言し割り当てたと思われます。すなわち、「test」変数は「heap」に「testclass」が割り当てたメモリアドレスがあると意味です。そして割り当てた「testclass」のデータを取得することはコンマ「.」の区切りで取得できます。「test」変数名は「testclass」が割り当ててメモリアドレスが格納されたことは理解しました。そうすると「test」で割り当てたクラスの「data」変数にデータを格納して見ましょう。上のソースを見るとクラスの構造の中で「data」のプロパティがありますが、読み専用になっています。でも,「setdata」のメソッドを見ると「&quot;test&quot;」の文字列を合成して「data」に格納するところがあります。そうするとメソッドを通って「data」に「data」の値を格納します。(合成されて「testdata」になる。)そして「data」プロパティを通って「data」の値を出力して結果を確認しましょう。予想とおりに結果を得られました。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/16.html</guid><pubDate>Thu, 11 Jul 2019 23:21:18 +0900</pubDate></item><item><title>[C# スタディ - 16] static</title><link>https://www.nowonbun.com/17.html</link><description><![CDATA[こんにちは。明月です。今日は「static」について勉強します。「static」は俗に静的キーワードと言います。「static」の種類は「staticメソッド」、「static変数」、「staticクラス」があります。staticメソッド今まで勉強したとおりならメソッドを使うためにはクラスを割り当てなければならないです。なぜなら、oopの最小単位はクラスだし、メソッドはクラスの内部に存在しているからです。でもクラスとは関係なく、計算だけするメソッドが必要な時もあります。例えば、パラメタで「int」タイプデータを２つを受け取って、パラメタの数を足す計算だけするメソッドがあると思いましょう。そしてそのメソッドを使うためにクラスを割り当てる(new)ことはメモリが惜しい感じがしますね。その時に「static」メソッドに実装すればクラスを割り当てずにメソッドを使うことができます。上の例を見ると「new」(割り当て)をしなくてメソッドを使います。そうすれば、staticメソッドからクラス内部のメンバ変数を使えるかと疑問になりますね。上をみるとエラーが発生しますね。なぜなら「static」メソッドの場合はクラスを割り当てて使うものではなく静的領域なので、動的なクラスの部分に直接に参照ができないです。でも、メソッドの中でクラスを割り当てたら使えます。static変数static変数は消されない変数だといいます。すなわち、クラスの変数はクラスが割り当てる時に変数の値が生成してクラスが解除する時に変数の値が無くなります。でも、プロジェクトの中で唯一に宣言するし、解除が行わない変数も必要だと思いますね。その時に使う変数を「static」変数と言います。staticクラス「staticクラス」はクラスの構成メンバがすべて構成が「static」になります。そしてstaticクラスの場合はコンストラクタをもってられません。なぜなら、「staticクラス」は割り当て(new)られないので、コンストラクタが存在できません。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/17.html</guid><pubDate>Wed, 10 Jul 2019 00:20:54 +0900</pubDate></item><item><title>[C# スタディ - 17] struct(構造体)</title><link>https://www.nowonbun.com/18.html</link><description><![CDATA[こんにちは。明月です。今日はstruct(構造体)について勉強します。struct「struct」の意味的には「class(クラス)」と同じですね。すなわち、データを縛る最小単位です。そうするとなぜ「class」と「struct」にキーワードを分けただろうかと言えばメモリ参照方法の差があります。「class」の場合は外部でメモリに割り当ててメモリ参照タイプとして使いますが、「struct」の場合は宣言する時に「struct」内部でメモリに割り当てて値タイプとして使うの差があります。上の例をみるとクラスの場合は「aclass」を宣言して「new」キーワードで割り当てます。そして「aclass」の変数「data」に「10」の値を格納します。その後で「bclass」を宣言して「aclass」をメモリアドレスを代入します。その後で「bclass」の変数「data」に「15」の値を格納すると「aclass」の変数「data」の値はどうでしょうか？前のクラスの投稿にも説明しましたが、上の場合は「aclass」と「bclass」が同じクラスを参照しているので両方「15」の値を持っていることを知っています。[c# スタディ - 15] クラス(class)とコンストラクタ、そしてnew(割り当て)そうすると「astruct」と「bstruct」も同じパタンを考えれば両方の変数「data」が「15」になると思われますね。結果を見れば予想結果と違いますね。結果を見ると「aclass」と「bclass」は確かに同じメモリアドレスを入っていますが、「astruct」と「bstruct」の場合はメモリアドレスが違いますね。すなわち「teststruct bstruct」を宣言する時に内部でメモリに割り当てて後「bstruct」に「astruct」の値をコピーしたと意味になります。そしたらこれから「struct」の使用方法について勉強してみましょう。とりあえず、上の構造を見ると「struct」もコンストラクタがあります。構造体の場合もコンストラクタを呼び出すためには「new」キーワードを使います。その場合は内部からメモリが割り当てることではなく、クラスみたいに外部からメモリが割り当てます。また、継承について勉強する前ですが、構造体はstructから継承ができません。(それで、プロパティを使いません。)でも、インタフェースからは継承を]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/18.html</guid><pubDate>Thu, 11 Jul 2019 23:18:03 +0900</pubDate></item><item><title>[C# スタディ - 18] enum(列挙型)</title><link>https://www.nowonbun.com/19.html</link><description><![CDATA[こんにちは。明月です。今日はenum(列挙型)について勉強します。前の投稿で「const」、「static」を勉強したことがあります。そのことを合わせて定義変数を作られることを知っています。「enum」の場合は定義変数と似ている概念ですが、データの値より集計的な区別のため使うキーワードです。それで「enum」は値のとしての意味を持ってることよりプロセス制御のため使えるものです。enum改めていうと、enumは分岐の制御のために整数を集合的に定義するものです。上の例を見ると「enum」は分岐制御の区別のために定義しています。上の型が一般的に「enum」を使う方法ですね。でも「enum」にも実際の整数を与えて設定するの方法もあります。上の例を見ると「enum」のメンバに実際整数を格納して、プラグとして使っています。でも「enum」には上みたいに整数は格納できますが、実数、文字(列)は格納できません。上の例は初めの例とにていますね。でも、前は「switch」文で分岐しましたが、今回は列挙変数「weak」を直接に出力しました。２つ目の例とおりなら「０〜７」間の数字が出力すると予想になります。結果は予想と違いますね。結果を見ると「enum」のメンバ名ままで出力しました。それで前の例と今回の例と比較すれば列挙型の上をみるとアトリビュート「flags」が付けていることを確認できます。「flags」のアトリビュートは「tostring」で出力する時にアトリビュート「flags」がなければ整数値、アトリビュート「flags」が付けていると「enum」の変数名が出力します。列挙変数「process」に値が「5」になることは予想できます。でも、列挙型のアトリビュートに「flags」が付けているので、変数名を出力しようとしますが、列挙メンバに「5」の値を持っているメンバがありません。この場合はビット演算子で計算したとおりに「type」、「type3」が出力します。]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/19.html</guid><pubDate>Wed, 10 Jul 2019 23:58:31 +0900</pubDate></item><item><title>[C# スタディ - 19]  継承とSealedクラス</title><link>https://www.nowonbun.com/20.html</link><description><![CDATA[こんにちは。明月です。今日は継承とsealedクラスについて勉強します。oopの特徴は抽象化、継承、多型、カプセル化があります。カプセルの場合はアクセス修飾子を勉強する時に説明したことがあります。[c# スタディ - 13] アクセス修飾子(public, private, protected)今日はoopの特徴の中の継承について勉強しましょう。継承この間にクラス、メソッド、プロパティ、変数の使用方法について勉強しました。正直にプログラムはその４つだけを知っても実装ができます。でも、プロジェクトが大きくなればなるほどその４つだけで実装が大変だし、出来上がった後を考えるとメンテおよびソース管理がすごく大変になると思います。その理由で継承は実装と管理のために使うと思っても結構です。継承の意味は親クラスから機能を引継いでもらい子クラスを生成することです。上の例をみると「successionbclass」を割り当てて「data1」のプロパティを呼び出します。でも「successionbclass」クラス内部には「data1」のプロパティがありません。しかし例の結果を見ると「successionbclass」に「data1」のデータが格納されるし、結果としても出力されます。なぜなら、「successionbclass」クラスは「successionaclass」クラスから機能をすべて継承したからのです。すなわち、「successionbclass」クラスは「successionaclass」クラスの機能をすべて使われると意味ですね。上の例を見ると「successionbclass」クラスの場合は「successionaclass」、「successioncclass」クラスと「successiondclass」クラスの場合は「successionbclass」を継承しています。もし、「successioncclass」のクラスと「successiondclass」のクラスが継承しなくてクラス内部で「data1」、「data2」を実装すると考えてみましょう。プロジェクト中で「data1」のデータタイプが「int」から「string」に修正することが発生すると継承しない場合は「successioncclass」のクラスと「successiondclass」のクラスを両方修正しなければならないのです。 しかし、継承してい]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/20.html</guid><pubDate>Thu, 11 Jul 2019 23:16:00 +0900</pubDate></item><item><title>[C# スタディ - 20] 抽象クラス、抽象メソッド、仮想メソッド</title><link>https://www.nowonbun.com/21.html</link><description><![CDATA[こんにちは。明月です。今日は抽象クラス、抽象メソッド、仮想メソッドについて勉強します。抽象クラス前の投稿で親クラスから継承すると親クラスの機能を引継いでもらって機能拡張をできることを勉強しました。でも、プロジェクトによって親クラス段階で仕様が決めておらず、派生クラス段階で仕様が決められる場合があります。例えば、各クラスの変数の初期値は違うけれど、変数、メソッドの構造が同様で作りたい場合があります。その時に親クラスからすべて一緒の変数、メソッドを作成して派生クラスからデータを取得するように作成します。その時に親クラスから取得メソッドの実装が決めておらず、派生クラス(子クラス)で実装させ、親クラスは派生クラスの実装させたことを呼び出すことです。すなわち、親クラスはそのメソッドを実装予約(抽象メソッド)して継承すれば実装することになっているクラスを抽象クラスといいます。抽象クラスと一般クラスの構造は同じですが、一般クラスは継承しなくてそのままクラスとして使えるけど抽象クラスの場合は継承しなくて使えません。抽象メソッド抽象メソッドの場合は必ず抽象クラス内だけ使えます。すなわち、抽象メソッドがあれば必ずクラスを抽象クラスに変換しなければならないという意味です。上の例を見ると「abstractclass」クラス内で抽象メソッド「getdate()」を宣言「abstract」しています。そのことを「childbclass」、「childcclass」クラスが継承して抽象メソッド「getdate()」を再実装「override」しています。そして親クラスのコンストラクタで派生メソッドを呼び出して変数「data」を設定しています。派生クラスの抽象メソッドを当該データから返却しています。結果を見ると各クラスの変数「data」の値を出力しています。そして結果は派生メソッドで返却したデータを「data」に格納して示させています。仮想メソッド抽象メソッドは親クラスで実装しておらず、派生クラスに実装を引継ぎます。でも、親クラスで全然実装しないことではなく、一部実装して派生クラス(子クラス)にも引き継いで再実装(override)する場合もあると思いますね。あるいは再実装しなく、親クラスのデフォルトに実装してメソッドを使われる時もあります。そのメソッドを仮想メソッドといいます。仮想メソッドは返却タイプ前に「virtual」とキーワード]]></description><category>Study / C#</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/21.html</guid><pubDate>Fri, 12 Jul 2019 00:18:43 +0900</pubDate></item><item><title>Devlopment note / Java</title><link>https://www.nowonbun.com/dev_java.html</link><description>Devlopment note / Java</description><category>Devlopment note / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_java.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / Java</title><link>https://www.nowonbun.com/study_java.html</link><description>Study / Java</description><category>Study / Java</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_java.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Open source</title><link>https://www.nowonbun.com/opensource.html</link><description>Open source</description><category>Open source</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/opensource.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Devlopment note / Javascript, Jquery, Css</title><link>https://www.nowonbun.com/dev_javascript.html</link><description>Devlopment note / Javascript, Jquery, Css</description><category>Devlopment note / Javascript, Jquery, Css</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_javascript.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / Javascript, Jquery, Css</title><link>https://www.nowonbun.com/study_javascript.html</link><description>Study / Javascript, Jquery, Css</description><category>Study / Javascript, Jquery, Css</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_javascript.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Project</title><link>https://www.nowonbun.com/project.html</link><description>Project</description><category>Project</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/project.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Devlopment note / Window</title><link>https://www.nowonbun.com/dev_window.html</link><description>Devlopment note / Window</description><category>Devlopment note / Window</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_window.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / PHP</title><link>https://www.nowonbun.com/study_php.html</link><description>Study / PHP</description><category>Study / PHP</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_php.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Experience</title><link>https://www.nowonbun.com/experience.html</link><description>Experience</description><category>Experience</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/experience.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Devlopment note / Linux</title><link>https://www.nowonbun.com/dev_linux.html</link><description>Devlopment note / Linux</description><category>Devlopment note / Linux</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_linux.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / Python</title><link>https://www.nowonbun.com/study_python.html</link><description>Study / Python</description><category>Study / Python</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_python.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Other</title><link>https://www.nowonbun.com/other.html</link><description>Other</description><category>Other</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/other.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Welcome</title><link>https://www.nowonbun.com/1.html</link><description><![CDATA[準備中]]></description><category>Other</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/1.html</guid><pubDate>Mon, 1 Jul 2019 01:42:41 +0900</pubDate></item><item><title>Devlopment note / Etc.</title><link>https://www.nowonbun.com/dev_etc.html</link><description>Devlopment note / Etc.</description><category>Devlopment note / Etc.</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/dev_etc.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / Database</title><link>https://www.nowonbun.com/study_database.html</link><description>Study / Database</description><category>Study / Database</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_database.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / Design pattern</title><link>https://www.nowonbun.com/study_design_pattern.html</link><description>Study / Design pattern</description><category>Study / Design pattern</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_design_pattern.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item><item><title>Study / Algorithm</title><link>https://www.nowonbun.com/study_algorithm.html</link><description>Study / Algorithm</description><category>Study / Algorithm</category><author>nowonbun@gmail.com</author><guid>https://www.nowonbun.com/study_algorithm.html</guid><pubDate>Fri, 12 Jul 2019 00:18:59 +0900</pubDate></item></channel></rss>